职业规划
毕业前两年我会在完成工作的前提下，尽量拓宽技术能力的宽度，同时培养理解业务、处理业务逻辑的能力，积累经验，让自己能得心应手得独立负责一个模块甚至一个系统的开发。后期3-5年，拥有一定经验之后，我希望能提升我对现有技能理解的深度，更多地去了解一个系统整体的构成，达到一个架构师或者服务器主程的基本要求。再往后我会在前面的基础上，再由技术过度到业务，毕竟技术能驱动业务，业务才能产生价值嘛。对我个人而言，我其实是希望能在技术这条路上走得越远越好的。


缺点
当下我最大的不足就是由于经验不足，能力较为局限在理论之上，对于实际的生产中会遭遇的问题认识比较粗浅吧。但我相信这个问题在我日后的工作中可以很快弥补。

优点
在学习中，我觉得我最大的优点是不服输，我会有无限的精力和冲劲去学习新的东西，不会因为困难而放弃，这个行业本身技术知识等更新迭代很快，我能够不懈怠地追求未知。其他方面，我觉得我觉得是感恩和知足吧，对于培养我的人和企业，包括学校，我会毫不吝啬地付出自己的价值，给予他们反馈，不辜负他们对我的期望。

java
抽象类，接口的区别
String,StringBuilder,StringBuffer
集合
	HashMap
		初始容量16，扩容*2
		数据结构：数组+单向链表/红黑树
		线程不安全，允许null键null值
		key不重复，不保证顺序
		最大容量2的30次方
		容量大于64，且链表长度达到8时树形化。降到6时链化。
		容量达到容量*负载因子（默认0.75）时扩容
	Hashtable HashSet TreeSet TreeMap
	ArrayList
		初始容量10，扩容1.5倍，如果不够，把需要的最小容量作为新容量。
		底层是数组
	LinkedList
		底层是双向链表
并发
	进程：
		是系统运行程序的基本单位
	线程：
		线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程，同类的多个线程共享进程的堆和方法区资			源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈。负担小得多。
	为什么要有多线程：
		线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核CPU时代意味			着多个线程可以同时运行，这减少了线程上下文切换的开销。

	线程的生命周期：
		1.创建（线程刚被new）
		2.运行（调用了start/或者notify）(分为就绪和运行的)
		3.阻塞（同步块没有获取到锁）
		4.等待（wait，sleep）
		5.终止（执行完成）
	避免死锁：
		1.互斥条件（无法破坏）
		2.破坏请求与保持条件（一次性申请所有资源）
		3.破坏不剥夺条件（占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。）
		4.破坏循环等待条件（靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。）
	sleep和wait区别：
		Thread类的方法  Object的方法
		sleep 方法没有释放锁，而 wait 方法释放了锁 。
		wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。
		wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。
		sleep()方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒。
	volatile
	    	volatile关键字是线程同步的轻量级实现，volatile性能比synchronized关键字要好。
		volatile关键字只能用于变量		
    		多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞
    		volatile关键字能保证数据的可见性，但不能保证数据的原子性。
    		volatile关键字主要用于解决变量在多个线程之间的可见性
	synchronized
		synchronized关键字可以修饰方法以及代码块
		synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以			及其它各种优化之后执行效率有了显著提升。
		synchronized关键字两者都能保证。
		synchronized关键字解决的是多个线程之间访问资源的同步性。
	ThreadLocal
		给每一个线程创建一个变量的本地副本
	实现Runnable接口和Callable接口的区别
		Runnable 接口不会返回结果或抛出检查异常，但是Callable 接口可以
		Executors 可以实现 Runnable 对象和 Callable 对象之间的相互转换
	CurrentHashMap
		1.7数组+Segment+分段锁的方式实现。对Segment加锁	
		1.8数组+链表+红黑树，采用CAS（比较交换）操作，对每个数组元素加锁
JVM

mysql
引擎对比
	MyISAM
		不支持事务
		会记录总行数
		非聚集索引
		只支持表锁
		可以没有主键
		不支持外键
		适合读多写少，并发量低，对数据一致性要求较低的场景
	InnoDB（默认）
		支持事务
		不会记录总行数
		聚集索引
		支持行锁和表锁
		必须有主键
		支持外键
		适合更新操作频繁，并发要求高，对数据一致性要求较高的场景
索引
	为什么用b+树：
		相对于二叉树，b+树不会退化成链，
		对比平衡二叉树，没有高额的维持平衡的开销，
		相对红黑树，b+树的高度低得多，
		对比哈希表，b+树可以实现范围查询。
		对比b树，b+树由于只有叶子结点有关键数据，因此其余节点相对更小，查询效率更稳定，也更适合范围查询。
	聚集索引的物理地址是连续的，非聚集索引不连续。
	二级索引：叶子节点中存储主键值，查找数据时，根据索引找到叶子节点中的主键值，根据主键值到聚簇索引中得到完整的一行记录。
	最左匹配：联合索引匹配的顺序是从左往右，第一个字段必须出现在查询组句中，索引才会被用到，当遇到范围查询时，下一个字段也			会放弃使用索引。
	覆盖索引：联合索引和查询条件字段完全相同，就可以直接通过遍历索引取得数据，无需回表，性能最优。
事务
	并发问题：
		1.脏读
		2.不可重复读
		3.幻读
	隔离级别：
		1.未提交读
		2.提交读
		3.可重复读
		4.串行化
	事务特性（ACID）
		1.原子性
		2.一致性
		3.隔离性
		4.持久性
锁
	行锁
		读锁（S锁、共享锁）
		写锁（X锁、排他锁）
	表锁
		意向共享锁（IS）
		意向排他锁(IX)
	乐观锁
		总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人		有没有去更新这个数据，可以使用版本号机制和CAS算法实现。适用于多读的应用类型，这样可以提高吞吐量。
	悲观锁
		总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁。适用于多写的应用类型。
三范式
	第一范式：数据库表中的所有字段值都是不可分解的原子值
	第二范式：没有部分依赖，一张数据表中的任何非主键字段都全部依赖于主键字段，没有任何非主键字段只依赖于主键字段的一部分
	第三范式：没有传递依赖，数据表的任何非主键字段之间都不产生函数依赖，即非主键字段之间没有依赖关系，全部只依赖于主键字段
一条SQL语句执行得很慢的原因有哪些
	1.没用上索引，走了全表扫描。
	2.日志被写满了，正在同步到磁盘。
	3.没拿到锁，被阻塞了。
哪些情况mysql不走索引
	1.使用<>，!=
	2.对条件字段进行函数操作或者表达式操作
	3.使用or
	4.模糊查询以%开头
	5.联合索引没有用到最左边的字段
	6.发生了隐式的类型转换
	7.在条件中判空
	8.使用in和not in
SQL的优化
	1.尽可能使用覆盖索引
	2.条件语句尽量配合索引最左匹配原则
	3.union all 代替or
	4.between代替in
	5.不要使用select *
	6.避免使用表达式、函数等操作作为查询条件
大表优化
	1.查询条件尽可能缩小
	2.读写分离，主写从读
	3.垂直分区，把一张列比较多的表拆分为多张表
	4.水平分区
优化数据库的一般步骤
	1.通过show status命令了解各种SQL的执行频率
		--查看查询时间超过long_query_time秒的查询的个数。
		show status like 'slow_queries';
		--查看select/delete等语句的执行数
		show global status like 'com_select';
	2.定位执行效率较低的SQL语句
	3.通过EXPLAIN分析较低SQL的执行计划
	4.通过show profile分析SQL的耗时时间等
	5.通过trace分析优化器如何选择执行计划
		1.查看优化器状态
		show variables like 'optimizer_trace'
		2.临时开启会话级别
		set session optimizer_trace = "enabled=on",end_markers_in_json=on;
		3.设置优化器追踪的内存大小
		set OPTIMIZER_TRACE_MAX_MEM_SIZE=1000000;
		4.执行sql
		5.查看information_schema.optimizer_trace表 优化过程
		select trace from information_schema.optimizer_trace
		6.导入到一个文件xx.trace用json阅读器查看
		select trace into dumpfile "E:\\test.trace" from information_schema.optimizer_trace
	6.确定问题并采取相应的优化措施
	
Spring
	IOC控制反转
		通过反射和xml配置的方式，将创建对象的权利反转给第三方spring容器，达到解耦的目的，让类的实现中不依赖其他对象的		创建。
	AOP面向切面
		基于动态代理，目标类有实现接口时用JDK动态代理，没有实现接口用cglib生成代理类
		通知：before（方法运行前）、after（方法结束后）、after-retruning（运行成功后）、after-throwing（抛出异常后）、			around(通知方法前后)
		注解：	1.Aspect配置一个切面类
			2.Pointcut定义一个切入点表达式（execution）
		场景：日志管理，性能监控，事务管理，权限校验
		
	管理bean的三种方式
		1.BeanWrapper
		2.BeanFactory接口（使用XmlBeanFactory）
		3.ApplicationContext（ApplicationContext建立在BeanFactory之上，并增加了其它功能）
	bean的配置方式（四种）
		1.构造器配置
		2.静态工厂
		3.setter方法
		4.实例工厂方法
	bean的作用域
		1.singleton：默认，每个容器中只有一个bean的实例
		2.prototype：为每一个bean请求提供一个实例
		3.request：为每一个网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。
		4.session：与request范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。
		5.global-session：全局作用域。
	bena的生命周期
		1.实例化Bean
		2.设置对象属性（依赖注入）
		3.处理Aware接口
		4.BeanPostProcessor
		5.InitializingBean与init-method：
		6.postProcessAfterInitialization
		7.DisposableBean：
		8.destroy-method：
	管理事务的方式
		1.编程式事务管理。在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法
　　		2.基于 TransactionProxyFactoryBean的声明式事务管理
　　		3.基于 @Transactional 的声明式事务管理
　　		4.基于Aspectj AOP配置事务
	隔离级别
		1.默认，使用底层数据库的隔离级别。
		2.未提交读 可能出现脏读。
		3.已提交读 不会出现脏读。
		4.可重复读 不会出现脏读和不可重复读。
		5.串行化 不会出现脏读，不可重复度和幻读。
	传播行为
		1.Required（默认）:如果有事务在运行，当前的方法就在这个事务内运行，否则开启一个新的事务，并在自己的事务内运行,
		2.Required_new:当前方法必须启动新事务，并在自己的事务内运行，如果有事务正在运行，则将它挂起
		3.Supports:如果有事务在运行，当前的方法就在这个事务内运行，否则可以不运行在事务中
		4.Not_supported:表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。
		5.Mandatory：当前的方法必须运行在事务内部，如果没有正在运行的事务，就会抛出异常
		6.Never：当前方法不应该运行在事务中，如果有运行的事务，就抛出异常
		7.Nested:如果有事务在运行，当前的方法就应该在这个事务的嵌套事务内运行。嵌套的事务可以独立于当前事务进行单独地			提交或回滚。如果当前事务不存在，那么其行为与PROPAGATION_REQUIRED一样。
	用到的设计模式
		1.工厂模式（BeanFactory创建bean）
		2.单例模式（spring的bean的默认作用域就是单例的）
		3.代理模式（SpringAOP基于动态代理）
		4.模板方法模式（jdbcTemplate等Template结尾的类）
		5.观察者模式（事件驱动模型）
		6.适配器模式（AOP的通知，以及MVC中的处理器适配器）
	是什么
		基于java的轻量级容器框架
	优点
		1.spring 提供 ioc 技术，容器会帮你管理依赖的对象，从而不需要自己创建和管理依赖对象了，更轻松的实现了程序的解耦
		2.spring 提供了事务支持，使得事务操作变的更加方便
		3.spring 提供了面向切片编程，这样可以更方便的处理某一类的问题
		4.更方便的框架集成，spring 可以很方便的集成其他框架，比如 MyBatis、hibernate 等

springmvc
	是什么
		Spring框架内置的MVC模式的实现，是一个轻量级web层框架。
	工作流程
		1.前端发送请求到前端控制器
		2.前端控制器查找处理器映射器请求对应的处理器并返回结果
		3.前端控制器调用处理器适配器来执行处理器并生成模型视图
		4.前端控制器调用视图解析器来解析生成视图对象
		5.前端控制器渲染并返回给用户
	优点
		1.可以支持各种视图技术,而不仅仅局限于JSP
		2.与Spring框架天然集成
		3.清晰的角色分配
		4.支持各种请求资源的映射策略
	常用注解
		1.@RequestMapping 用于类或方法上。表示响应请求的方法的路径。
		2.@Resource和@Autowired注入bean。前者按名称，后者按类型
		3.@Controller @Repository @Service
		4.@ResponseBody 将返回页面变成返回json
		5.@RequestBody 接收字符串

mybatis
	是什么
		是基于java的半自动的orm持久层框架（orm是对象关系映射）
	优点
		1.节省了频繁创建和释放连接的操作，让程序员更专注于sql实现。
		2.将sql放在配置文件中，进行统一管理，可读性更好，利于维护。
		3.能够对结果集进行映射，节省了封装步骤。
		4.可以通过参数映射，生成动态sql语句。
		5.增加了连接池的管理，以及缓存的管理。
	#和$的区别
		1.#{}是预编译处理，${}是字符串替换。
		2.使用#{}可以有效的防止SQL注入，提高系统安全性。
	分页
		1.Mybatis使用RowBounds对象进行分页
		2.使用分页插件，pageHelper
	注解
		1.@Param 参数别名
		2.resultType 返回值类型
		3.parameterType 参数类型
		4.id 绑定方法名

redis
	是什么
		是一个用C语言编写的Key-Value型非关系型数据库
	优点
		1.速度快，因为是纯内存操作
		2.支持的数据类型丰富，且根据他们的特性有不同的应用场景
		3.支持事务
	数据结构以及使用场景
		1.String 	缓存，计数
		2.List		关注列表，消息队列，最新消息排行
		3.Set		共同关注，共同好友
		4.Zset		即时排行榜，带权重的消息队列
		5.Hash		对象数据存储
	内存淘汰机制
		1.noeviction(默认)：不删除策略, 达到最大内存限制时, 如果需要更多内存, 直接返回错误信息。
		2.allkeys-lru：所有key通用; 优先删除最近最少使用的key【随机抽取n（n可设置）个键，删除其中最近最少使用的键】
		3.volatile-lru：只限于设置了expire的部分; 优先删除最近最少使用的key【随机抽取n（n可设置）个键，删除其中最近最				少使用的键】
		4.allkeys-random：所有key通用; 随机删除一部分key
		5.volatile-random：只限于设置了 expire 的部分; 随机删除一部分key
		6.volatile-ttl：只限于设置了expire的部分; 优先删除剩余时间短的key
	缓存雪崩
		缓存在同一时间内大量键过期（失效），接着来的一大波请求瞬间都落在了数据库中导致连接异常。
		解决：即根据key获取value值为空时，锁上，从数据库中load数据后再释放锁。若其它线程获取锁失败，则等待一段时间后重		试。或者建立缓存备份
	缓存穿透
		指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数			据每次请求都要到数据库去查询，造成缓存穿透。
		解决：布隆过滤器（一种数据结构，可以判断是否不存在）
	保证redis和数据库数据一致性
	分布式锁
		通过set获取锁，同时设置用于解锁的id和过期时间，其他端获取锁时判断该key是否存在，存在说明锁还未被释放，不作操作
	为什么快
		1.因为redis是单线程的，没有上下文切换的开销
		2.因为是C语言编写更接近底层
		3.因为是键值对型数据库，查询效率是O（1）
		4.因为是纯内存操作
	为什么单线程
		1.因为单线程可以避免上下文切换的开销和多线程竞争问题
		2.因为其采用了io多路复用，多个网络连接公用一个线程
	主从同步 
		1.全量同步
			通常发生在从服务器初始化的阶段，这时候需要把主服务器上所有数据都复制一份。
			步骤：
				①从服务器连接主服务器，并发送sync命令
				②主服务器收到sync命令，开始执行BGSAVA命令生成RDB文件，同时使用缓冲区记录之后执行的所有写命令
				③主服务器执行完BGSAVE命令后，向所有从服务器发送快照文件，并同时继续记录执行的所有写命令
				④从服务器收到快照文件之后，丢弃所有旧数据，载入收到的快照信息
				⑤主服务器发送完所有快照之后开始向从服务器发送缓冲区中记录的写命令
				⑥从服务器载入完快照信息，开始接收命令请求，并执行主服务器缓冲区发送来的写命令

		2.增量同步
			主服务器每执行一个写命令就向从服务器发送相同的写命令，从服务器接收并执行该命令
		3.策略：主从刚开始连接，初始化时采用全量同步；之后采用增量同步；首先尽可能采用增量同步，不成功时采用全量同步
	哨兵机制
		启动多个哨兵进程，用来对redis节点的运行状态监控，主服务器发生故障时，通过投票机制，从从服务器中选举新的主服务		器，实现主从切换	
	如何保证redis中的数据都是热点数据
		使用适合的数据淘汰策略。

Linux
	常用命令
		查看cpu占用情况		top
		查看内存占用情况	free
		查看占用端口的进程	netstat(可以使用管道 | grep 加端口号查看固定端口的进程)
		查看所有进程		ps
		杀死进程		kill(-9强制)
		查看文件		tail/cat
		编辑文件		vim
		查看当前路径		pwd	
		修改文件权限		chmod 三个数字
网络
http http1.1 https
	请求，响应的格式（请求头等）
osi模型
	应用层
	表示层
	会话层
	网络层
	传输层
	数据链路层
	物理层
udp
状态码
浏览器访问网页的过程
SSL/TLS
Cookie和Session的区别
get和post的区别
	1.get请求的参数数据会附加在url后面，post请求的参数数据在请求体中
	2.get请求的安全性不如post请求

常见算法：
排序
				冒泡 稳定 O(n^2) O(1)
				适用于比较元素较少，且数组基本上有序的情况。
				快排 不稳定 O(nlog2n) 对数级 最坏情况会到O(n^2) O(log2n)
				适用于比较元素较多，多数场景下效率较好，在数组有序的时候效率会降为O(n^2)
				选择 不稳定 O(n^2) O(1)
				移动次数较少，适用于大多数场景。
				插入 稳定 O(n^2) O(1)
				适用于大部分有序的场景。
				桶 稳定 O(n) 线性 O(m+n)
				适用于元素值基数不大的场景,数量大，但重复多最佳。
				希尔 不稳定 O(n^1.3-2) O(1)
				适用于大型的数组排序。
				堆 不稳定 O(nlogn) O(1)
				适用于数据量非常大的场景。
				归并 稳定 O(nlogn) O(n)
				适用于外部排序，需要稳定性，可牺牲空间效率的场景。


对微服务架构的理解：
	是一种架构模式，将单机应用，根据业务划分为多个小的服务，不同的服务分管不同的业务，每个服务独立运行在进程中。服务之间采	用轻量级通信机制（http restful）互相通信。
优点：
	1.每个服务足够内聚，足够小，代码容易理解这样能聚焦一个指定的业务功能或业务需求
	2.开发简单、开发效率提高，一个服务可能就是专一的只干一件事。
	3.微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的。
	4.微服务能使用不同的语言开发。
	5.每个微服务都有自己的存储能力，可以有自己的数据库。也可以有统一数据库。
缺点：
	1.运维的压力增大
	2.系统部署依赖
	3.服务间通信有成本
	4.数据一致性
	5.系统集成测试
	6.性能监控

CAP理论，C强一致性，A高可用，P分区容错性，无法同时满足三个，永远要保证P。
AP允许一段时间内数据的不一致，保证高可用。
CP牺牲可用性，保证数据的一致准确。

springcloud的理解：
	分布式微服务架构的一站式解决方案，多种微服务架构技术的落地实现。

组件：
1.服务注册与发现:
	作为一个服务的注册中心，各个服务将自己的信息注册到服务中心，调用者就可以使用服务别名去注册中心获取服务的实际地址，方便管理服务之间的依赖关系，也方便维护人员监控各个微服务的运行情况。 
	Eureka（停更）@EnableEurekaClient
		分为eureka客户端@EnableEurekaServer和eureka服务端@EnableEurekaClient两个组件，且在客户端内置了一个轮询				的负载均衡器。各个服务会定时发送心跳（默认30s）给eureka服务器，如果长时间没有收到心跳，eureka会把注册的这个服		务节点移除。
		为了高可用，可以构建集群，多个eureka服务器互相关联守望。
		@DiscoveryClient服务发现，可以看到注册的服务的信息
		自我保护机制：当注册的某个微服务临时不可用（比如网络卡顿）时，eureka保存它的信息一段时间。保证高可用。可以配置			关闭。
	Zookeeper	@EnableDiscoveryClient
		服务不可用以后（一定时间内没有收到心跳），被立刻移除，不会保存。
	Consul		@EnableDiscoveryClient
		GO语言开发的，有可视化界面。
	Nacos

	异同点：
		eureka关注CAP理论中的AP（保证高可用），consul和zookeeper更关注CP（保证强一致）
		Eureka和zookeeper用java编写，consul用go编写
		eureka和consul对外的形式是web界面，zookeeper是linux的客户端
		Zookeeper有Leader和Follower角色，Eureka各个节点平等。

2.服务的通信和负载均衡	
	Ribbon（负载均衡+restTemplate调用）
		客户端（本地）负载均衡工具，在服务调用的时候，到注册中心上获取服务注册列表缓存到jvm本地，然后实现RPC远程服务调		用。
		负载均衡策略（IRule）：轮询、随机、轮询失败重试、按响应速度加权选择、过滤断路服务、过滤故障实例等。
		如何替换：创建配置类（不能放在主启动类包下），返回IRule下的具体规则实现类实例，在主启动类上加@RibbonClient
		自定义：
		轮询原理：取下标为 rest请求次数%服务器集群总数，每次重启后次数重置为1。用到了原子类和比较并交换（CAS）保证并发		安全。
	Feign（停止更新）
	OpenFeign（@EnableFeignClient）
		一个声明式的web服务客户端，在接口上创建注解即可。能让编写java http客户端更容易。
		在客户端定义一些接口，并以注解的方式配置它，让其与服务端接口绑定。
		整合了ribbon，可以使用它的负载均衡，整合了Hystrix，具有熔断的能力
		超时控制：默认1秒，超过后报错（可配置）
		日志增强：可以配置调整日志级别，了解http请求细节，对feign接口的调用情况进行监控（null/basic/headers/full）,在			配置类中配置。
3.服务熔断、降级
	为了防止整个架构上某个微服务响应时间过长或者不可用了，而引起整个系统的崩溃。在某个服务发生故障时，给调用者返回一个合适	的响应，而不是等待很长时间或者抛出无法处理的异常，避免分布式服务故障蔓延。
	hystrix
		服务降级：在程序运行异常、超时、线程池满等等时候，返回一个友好提示，不让请求等待太久。
			@HystrixCommand配置接口发生问题时临时调用哪个降级方法。
			@HystrixProperty配置降级问题（超时、异常等）
			@DefaultProperties配置全局服务降级
		服务熔断：类似保险丝，在服务出现问题时，拒绝访问，调用后备的降级方法，快速返回错误信息，然后缓慢恢复服务。
			会监控调用情况，在一定时间内调用失败次数达到一定阈值（可配置）时，打开熔断器，一段时间以后进入半熔断。
		服务限流：短时间内高并发场景下，比如秒杀，要限制流量。
		dashboard图形化：可以以图形化页面的形式监控服务（可以监控断路器信息和一些运行参数）
	resilience4j
	sentinel
4.网关
	客户端到服务端的第一层关卡，用来做路由转发和过滤（如权限校验、限流以及监控），同时可以隐藏真实的服务器地址端口
	zuul
		基于阻塞IO模型
	getaway
		底层借鉴了netty通讯框架，加上webflux，框架异步非阻塞模型，支持websocket,能和spring无缝结合。
		判断断言，根据路由分发到合适的服务，过滤器可以像aop那样对服务做一定的增强（权限校验、流量监控、日志输				出等）。
		可以在yml中配置，也可以使用配置类，注入RouteLocator
		可以根据注册中心的服务列表，实现动态路由，只需要配置uri为服务名即可
		请求限流
		路径重写
5.配置中心
	分布式系统随着服务工程越来越多，配置文件越来越多，越来越不方便管理。而且测试环境、开发环境、线上环境也各自需要配置。
	配置中心就解决这个问题，让配置集中化，一处配置处处生效。
	config
		设置一个配置中心服务端（@EnableConfigService），连接各个服务，为他们提供配置信息，在配置变化的时候，自动拉取更			新配置。使用一个外部配置，与github之类的整合，在github上修改具体的配置信息。
		微服务配置刷新的功能（@RefreshScope），然后向微服务端发送一个post请求即可刷新。
	Nacos
6.服务总线
	服务总线可以结合消息中间件，构建一个topic让所有服务监听，这样就可以广播推送或者定点推送一些消息到所有服务。如：只凭借		配置中心无法做到配置全自动的动态刷新，也无法广播刷新。服务总线与config配合就可以实现。
	bus
		bus可以结合消息代理（kafka或rabbitmq）,在修改了配置之后，将信息发送到消息中间件，订阅了消息，推送到config服务		端,最后通过消息总线，广播蔓延到全部需要配置的微服务。
	Nacos
7.消息中间件（消息队列）
	rabbitMQ
		Erlang语言编写的消息队列。消息的发送者先将消息发出，消息队列服务器Broker会选择交给vhost中对应的交换器Exchange		，交换器Exchange根据消息的路由键选择它所绑定的合适的队列（Queue），最后消息的接收者就可以取出队列中的消息了。
		1.direct（默认）：路由键直连对应，点对点单播，路由键直接与绑定规则进行匹配，如果完全一致，则可以转发。
		2.fanout：广播式的交换器，将收到的消息广播到所有绑定的队列中，速度是最快的。
		3.topic：路由键模式匹配，路由键可通过模糊匹配绑定规则，路由键和绑定规则都被切分成单词的形式，分隔符为‘.’，可		使用两个通配符‘*’,‘#’。‘*’匹配一个单词，‘#’匹配0个或多个单词，只要符合匹配规则，就会转发。
		应用场景：
			1.异步处理
			2.应用解耦
			3.流量削峰：在高并发场景下，以秒杀系统为例，会存在短时间内的超高流量，如果所有请求都打到服务器是极其危			险的。设置一个定长的消息队列，接受限定数额的请求消息到消息队列中，将之后的请求拦截在外，服务器只需要处			理消息队列中的请求即可。
		形式：
			1.队列
			2.主题
8.服务开发
	springboot

JVM	
运行时内存
	线程独占的：
			1.程序计数器
			2.本地方法栈
			3.虚拟机栈
		线程共享的：
			1.堆
			2.方法区
类加载过程
类加载器
双亲委派模型
GC算法
		1.标记-清楚算法
		2.复制算法
		3.标记-整理算法
		4.分代收集算法
	判断对象死亡：
		1.引用计数法
		2.可达性分析算法
垃圾回收器
serial
parnew

常用参数
-Xms				初始堆内存
-Xmx				最大堆内存
-Xss				栈内存
-Xmn				新生代内存
-XX:+PrintGCDetails		打印GC日志
-XX:+useXXGC			使用xxGC垃圾回收器
-XX:mataspaceSize = ?		元空间内存
-XX:SurvivorRatio=?		伊甸区和幸存区内存的比例
-XX:NewRatio=?			新生代和老年代的比例
-XX:MaxTenuringThreshold=?	新生代对象最多多少次存活移到老年代
-XX:PrintFlagsIntial		打印JVM初始参数
-XX:PrintFlagsFinal		打印JVM最终参数


命令
jps -l
jinfo flag 具体参数 线程号 



IO
多线程
集合
springmvc
springboot
mybatis
linux
mysql
缓存
消息队列
	rabbitMQ


请求-》负载均衡（nginx）-》网关->微服务






