{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[],"note":"","watermark":"","children":[{"parent":"root","lineStyle":{"randomLineColor":"#0F80C4"},"children":[{"parent":"b8cc68fc0f5a","children":[],"id":"f828911bce50","title":"解决<font color=\"#f44336\">单点问题</font>和<font color=\"#f44336\">性能上限</font>问题"}],"id":"b8cc68fc0f5a","title":"目的"},{"parent":"root","lineStyle":{"randomLineColor":"#DD489D"},"children":[{"parent":"e57a3a16f834","children":[{"parent":"dce4bf6272cf","children":[],"id":"9610c4e01cd9","title":"是一种物理形态"}],"id":"dce4bf6272cf","title":"集群"},{"parent":"e57a3a16f834","children":[{"parent":"a0021df0ef86","children":[{"parent":"96edd7f28706","children":[{"parent":"cf3994fb0ac1","children":[],"id":"6958c2244aed","title":"（Service&nbsp;Oriented&nbsp;Architecture）“面向服务的架构”"}],"id":"cf3994fb0ac1","title":"SOA<br>"},{"parent":"96edd7f28706","children":[{"parent":"da64cceab535","children":[],"id":"a940eca72749","title":"https://segmentfault.com/img/remote/1460000038349187"}],"id":"da64cceab535","title":"微服务"}],"id":"96edd7f28706","title":"是一种工作方式"}],"id":"a0021df0ef86","title":"分布式"}],"boundaries":[{"boundary":true,"parent":"e57a3a16f834","boundRank":1,"children":[],"range":"0,1","style":{"lineType":"1","dasharray":"6,3","opacity":"0.1","lineWidth":"2"},"id":"8eab2b18d168","title":"外框"},{"boundary":true,"parent":"e57a3a16f834","boundRank":2,"children":[],"range":"1,1","style":{"lineType":"1","dasharray":"6,3","lineColor":"rgb(113, 203, 45)","opacity":"0.1","fill":"rgb(113, 203, 45)","lineWidth":"2"},"id":"48fc639c785b","title":"外框"}],"id":"e57a3a16f834","title":"概念区别"},{"parent":"root","lineStyle":{"randomLineColor":"#02ACF4"},"children":[{"parent":"c7f0b75ad609","children":[],"id":"688a1e80f362","title":"节点与网络"},{"parent":"c7f0b75ad609","children":[],"id":"ee586592a361","title":"时间与顺序"},{"parent":"c7f0b75ad609","children":[{"parent":"85c06910ee25","children":[{"parent":"953d88d30b23","children":[],"id":"d36b338bb05f","title":"ACID（强一致性/线性一致性模型）"},{"parent":"953d88d30b23","children":[{"parent":"7f7f558be3c8","children":[{"parent":"df39f750f634","children":[],"id":"c05159d0adf4","title":"CP模式"},{"parent":"df39f750f634","children":[],"id":"005d63d76a51","title":"ZAB协议"}],"id":"df39f750f634","title":"zookeeper"}],"id":"7f7f558be3c8","title":"举例"}],"id":"953d88d30b23","title":"CP"},{"parent":"85c06910ee25","children":[{"parent":"0a7fc6286734","children":[{"parent":"51d7546cb2a6","children":[],"id":"a3a3ce8f6ad4","title":"弱一致性"},{"parent":"51d7546cb2a6","children":[{"parent":"d841f86cb7d8","children":[{"parent":"ff3969b86768","children":[],"id":"f9ab6a75a27b","title":"任何时候读写都是成功的"}],"id":"ff3969b86768","title":"BA（基本可用）"},{"parent":"d841f86cb7d8","children":[{"parent":"ae315f5fbc68","children":[],"id":"ee12d1596c75","title":"允许数据存在中间状态<br>即允许系统在多个不同节点对副本数据存在延时"}],"id":"ae315f5fbc68","title":"S（软状态）"},{"parent":"d841f86cb7d8","children":[{"parent":"124cac380de1","children":[{"parent":"47830e3285ef","children":[],"id":"6efa891be7f8","title":"会话一致性"}],"id":"47830e3285ef","title":"因果一致性"}],"id":"124cac380de1","title":"A（最终一致性）"}],"id":"d841f86cb7d8","title":"内容"}],"style":{"background-color":"rgb(80, 194, 139)","border-radius":"5px","color":"rgb(255, 255, 255)","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"51d7546cb2a6","title":"BASE理论方案"}],"id":"0a7fc6286734","title":"AP"}],"style":{"background-color":"rgb(80, 194, 139)","border-radius":"5px","color":"rgb(255, 255, 255)","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"85c06910ee25","title":"CAP理论"},{"parent":"c7f0b75ad609","children":[{"parent":"bf1bef214bdb","children":[{"parent":"a9a3ecb9f5d8","children":[{"parent":"529730cdd0db","children":[],"id":"bbb5a52de191","title":"经典算法，后续的算法都是基于Paxos的拓展"}],"id":"529730cdd0db","title":"地位"},{"parent":"a9a3ecb9f5d8","children":[],"style":{"background-color":"rgb(219, 226, 227)","border-radius":"6px","color":"rgb(67, 75, 84)","border-color":"rgb(67, 75, 84)","border-width":"0px","border-style":"none"},"id":"b3482079c48f","title":"WARO机制（Write All ReadOnly）"},{"parent":"a9a3ecb9f5d8","children":[{"parent":"7ea19c06b196","children":[],"id":"79b03e6d33c6","title":"Quorum&nbsp;的定义如下：假设有&nbsp;N&nbsp;个副本，更新操作&nbsp;wi&nbsp;在&nbsp;W&nbsp;个副本中更新成功之后，才认为此次更新操作&nbsp;wi&nbsp;成功，把这次成功提交的更新操作对应的数据叫做：“成功提交的数据”。对于读操作而言，至少需要读&nbsp;R&nbsp;个副本才能读到此次更新的数据，其中，W+R&gt;N&nbsp;，即&nbsp;W&nbsp;和&nbsp;R&nbsp;有重叠，一般，W+R=N+1。\n\nN&nbsp;=&nbsp;存储数据副本的数量\n\nW&nbsp;=&nbsp;更新成功所需的副本\n\nR&nbsp;=&nbsp;一次数据对象读取要访问的副本的数量\n\nQuorum就是限定了一次需要读取至少N+1-w的副本数据,听起来有些抽象，举个例子，我们维护了10个副本，一次成功更新了三个，那么至少需要读取八个副本的数据，可以保证我们读到了最新的数据。"},{"parent":"7ea19c06b196","children":[],"id":"f05f01e2b4b0","title":"在&nbsp;Paxos、Raft&nbsp;和&nbsp;ZooKeeper&nbsp;的&nbsp;Zab&nbsp;等算法中，都可以看到&nbsp;Quorum&nbsp;机制的应用。"}],"collapsed":false,"id":"7ea19c06b196","title":"前提：Quorum机制"},{"parent":"a9a3ecb9f5d8","children":[],"id":"d6c4a29927dc","title":"具体实现"}],"style":{"background-color":"rgb(255, 83, 92)","border-radius":"6px","color":"rgb(255, 255, 255)","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"a9a3ecb9f5d8","title":"Paxos"},{"parent":"bf1bef214bdb","children":[],"style":{"background-color":"#4DD0E1","border-radius":"5px","color":"rgb(255, 255, 255)","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"12bd4ed005aa","title":"Raft"},{"parent":"bf1bef214bdb","lineStyle":{"lineColor":"#4DD0E1"},"children":[{"parent":"b68638161d6d","children":[{"parent":"36f9a70b67ab","children":[],"id":"016e26dcffdc","title":"（Zookeeper&nbsp;Atomic&nbsp;Broadcast）Zookeeper&nbsp;原子消息广播协议"}],"id":"36f9a70b67ab","title":"全称"}],"style":{"background-color":"#4DD0E1","border-radius":"5px","color":"rgb(255, 255, 255)","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"b68638161d6d","title":"ZAB"},{"parent":"bf1bef214bdb","children":[],"id":"f97e7247a96f","title":"CALM"},{"parent":"bf1bef214bdb","children":[],"id":"a220b77c4647","title":"Gossip"},{"parent":"bf1bef214bdb","children":[],"id":"ecd202cc559f","title":"CRDTs"},{"parent":"bf1bef214bdb","children":[],"id":"a65024e90ca7","title":"HATs"}],"collapsed":false,"boundaries":[{"boundary":true,"parent":"bf1bef214bdb","boundRank":1,"children":[],"range":"0,0","style":{"lineType":"1","dasharray":"6,3","opacity":"0.1","lineWidth":"2"},"id":"9912f12049df","title":"外框"}],"id":"bf1bef214bdb","title":"一致性算法"}],"boundaries":[{"boundary":true,"parent":"c7f0b75ad609","boundRank":1,"children":[],"range":"2,2","style":{"lineType":"1","dasharray":"6,3","opacity":"0.1","lineWidth":"2"},"id":"a12e65e1c711","title":"外框"}],"id":"c7f0b75ad609","title":"基础理论"},{"parent":"root","lineStyle":{"randomLineColor":"#FA5465"},"children":[{"parent":"520e70c58b6f","children":[],"id":"dba83a5f4b71","title":"文件系统"},{"parent":"520e70c58b6f","children":[],"id":"e7175abbb264","title":"计算"},{"parent":"520e70c58b6f","children":[{"parent":"a2bfaf42f759","children":[],"id":"9dbe00254678","title":"举例：Redis、Mysql等"},{"parent":"a2bfaf42f759","children":[{"parent":"4a01abb2c15d","children":[],"id":"54166edab1ff","title":"单机"},{"parent":"4a01abb2c15d","children":[{"parent":"04036611722f","children":[{"parent":"38f51ec667e3","children":[],"id":"d20246b3013c","title":"双机热备这一概念包括广义、狭义两种意义。<br>从<font color=\"#f44336\">广义上</font>讲，就是对于重要的服务，<font color=\"#f44336\">使用两台服务器，互相备份</font>，共同执行同一服务。当一台服务器出现故障时，由另一台服务器承担服务任务，从而在不需要人工干预的情况下，自动保证系统能持续提供服务。双机热备由备用的服务器解决了在主服务器故障时服务不中断的问题。<br>从<font color=\"#f44336\">狭义上</font>讲，双机热备特指<font color=\"#f44336\">基于active/standby方式</font>的服务器热备。服务器数据包括数据库数据同时往两台或多台服务器执行写操作，或者使用一个共享的存储设备。<font color=\"#f44336\">在同一时间内只有一台服务器运行</font>。当其中运行着的一台服务器出现故障无法启动时，另一台备份服务器会通过软件诊测（一般是通过心跳诊断）将standby机器激活，保证应用在短时间内完全恢复正常使用。<br><br>参考：https://baike.baidu.com/item/%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87%E7%B3%BB%E7%BB%9F/8666995"}],"collapsed":true,"id":"38f51ec667e3","title":"定义"},{"parent":"04036611722f","children":[{"parent":"3efd93242af3","children":[{"parent":"68d4051c41e7","children":[{"parent":"6a8e5b8abe25","children":[{"parent":"9956dcb4df03","children":[],"id":"f0b3f1b973e7","title":"单项同步中的主备和主从，都不会分担写操作；主主模式会分担写操作，但是写操作就会带来很多问题"}],"id":"9956dcb4df03","title":"目的"},{"parent":"6a8e5b8abe25","children":[{"parent":"6f3e400a5a87","children":[{"parent":"ce8f3eaa49ab","children":[],"id":"98496f9ab973","title":"一台奇数主键、一台偶数主键"}],"id":"ce8f3eaa49ab","title":"主主模式下，两台数据库都在写数据，主键如何设计？？"},{"parent":"6f3e400a5a87","children":[{"parent":"cbd592c10e24","children":[],"id":"6999841aee3b","title":"前提：业务上是不允许同一时刻，多个客户端对同一条数据进行增删改，由分布式锁去控制<br><br><br>具体：同一时刻，客户端A修改DB1中id=50的name为Tom，客户端B修改DB2中id=50的name为Jack，客户端A和B只有一个会获取到分布式锁"},{"parent":"cbd592c10e24","children":[],"id":"630c18e81654","title":"分析：同步时延会造成主1和主2的数据不一致，同步时延这个间隙时间，会可能让用户读到旧数据，并基于旧数据开展业务"}],"style":{"background-color":"rgb(255, 83, 92)","border-radius":"6px","color":"rgb(255, 255, 255)","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"cbd592c10e24","title":"主主模式下，两台数据库都在写数据，如何保证一致性？？"}],"id":"6f3e400a5a87","title":"问题"},{"parent":"6a8e5b8abe25","image":{"w":356,"h":229,"url":"http://cdn.processon.com/625fb59e1e085306fa783ab4?e=1650443182&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:CvTu8uRPCfimzWRWHk1HjJMOLQk=","direction":"up"},"children":[],"id":"bb9027bc5b69","title":""}],"collapsed":true,"id":"6a8e5b8abe25","title":"主主"}],"collapsed":false,"style":{"background-color":"rgb(80, 194, 139)","border-radius":"5px","color":"rgb(255, 255, 255)","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"68d4051c41e7","title":"双向同步（广义）"},{"parent":"3efd93242af3","children":[{"parent":"a04590f162ac","children":[{"parent":"3f3844535c00","image":{"w":359,"h":230,"url":"http://cdn.processon.com/625fb5541efad40734c4a0f3?e=1650443108&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:q6I7_VTGLs8sBnDPU1PEzjvXEyY=","direction":"up"},"children":[],"id":"a596b4654d57","title":"主机读写，并同步到备用机；备用机不对外读写，当主机异常，备机则担任读写任务<br><br>"}],"collapsed":false,"id":"3f3844535c00","title":"主备"},{"parent":"a04590f162ac","children":[{"parent":"f0bc85826133","image":{"w":361,"h":229,"url":"http://cdn.processon.com/625fb564f346fb0727860834?e=1650443124&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:KWFR0BD3mMPE-SIQcumPtETCFoM=","direction":"up"},"children":[],"id":"4293dde73ef4","title":"主机读写，并同步到备用机；备用机对外只读，当主机异常，备机则担任读写任务<br><br>"}],"collapsed":false,"id":"f0bc85826133","title":"主从"},{"parent":"a04590f162ac","children":[{"parent":"81fec8657c52","children":[],"id":"6ff1e3a33bad","title":"主备：读写压力都在主机，性能不如方案二"},{"parent":"81fec8657c52","children":[],"id":"ad1d8f3523d1","title":"主从：数据一致性是最终一致性。用户改了主机数据后，因为<font color=\"#f44336\">网络延时问题</font>，数据还未同步到从机，所以从机读的数据是旧数据<br><br>异地主备时延 &gt; 同城主备时延"}],"id":"81fec8657c52","title":"缺点"}],"collapsed":true,"style":{"background-color":"rgb(80, 194, 139)","border-radius":"5px","color":"rgb(255, 255, 255)","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"a04590f162ac","title":"单项同步（狭义）"}],"collapsed":false,"id":"3efd93242af3","title":"模式"},{"parent":"04036611722f","children":[{"parent":"c3a62074b0fa","children":[{"parent":"23d36558b87f","children":[{"parent":"dd6f3b13b6f3","image":{"w":512,"h":226,"url":"http://cdn.processon.com/625fca517d9c0807247881ff?e=1650448481&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:9KSa3eT9EUyLYGgBIk0i9PbEHis=","direction":"up"},"children":[],"id":"a530191cda76","title":""},{"parent":"dd6f3b13b6f3","children":[],"id":"fad9247afabb","title":"主库提交事务后，直接响应客户端"}],"id":"dd6f3b13b6f3","title":"异步复制（v5.5之前）"}],"id":"23d36558b87f","title":"不保证一致性"},{"parent":"c3a62074b0fa","children":[{"parent":"8dfa06ba6486","children":[{"parent":"60d7d9fbaf6e","image":{"w":512,"h":239,"url":"http://cdn.processon.com/625fca9de0b34d07216549b9?e=1650448557&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:Y98H3OH8y3YmMMn7KbdPWqMJvyg=","direction":"up"},"children":[],"id":"9de9a9f1fbb6","title":""},{"parent":"60d7d9fbaf6e","children":[],"id":"31cbcc357ac4","title":"主库提交事务后，等待同步线程将数据同步到从库的IO线程后，从库IO线程返回响应主库，主库返回响应客户端"}],"collapsed":false,"style":{"background-color":"rgb(80, 194, 139)","border-radius":"5px","color":"rgb(255, 255, 255)","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"60d7d9fbaf6e","title":"半同步复制"},{"parent":"8dfa06ba6486","children":[{"parent":"557d2d0a468d","children":[],"id":"f8fd58d65e11","title":"主库从库均完成事务后，才返回响应客户端"}],"style":{"background-color":"rgb(80, 194, 139)","border-radius":"5px","color":"rgb(255, 255, 255)","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"557d2d0a468d","title":"全同步复制"}],"boundaries":[{"boundary":true,"parent":"8dfa06ba6486","boundRank":1,"children":[],"range":"0,1","style":{"lineType":"1","dasharray":"6,3","opacity":"0.1","lineWidth":"2"},"id":"58e69b3b7ffb","title":"外框"}],"id":"8dfa06ba6486","title":"保证一致性"}],"collapsed":false,"boundaries":[],"style":{"background-color":"rgb(80, 194, 139)","border-radius":"5px","color":"rgb(255, 255, 255)","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"c3a62074b0fa","title":"Mysql同步机制<br>（Mysql同步如何保证数据一致性）"},{"parent":"04036611722f","children":[],"id":"50a94030936d","title":"Mysql同步失败如何处理"}],"collapsed":false,"id":"04036611722f","title":"双机热备"}],"collapsed":false,"boundaries":[],"id":"4a01abb2c15d","title":"Mysql部署方式"},{"parent":"a2bfaf42f759","children":[],"id":"b1ccb5c6db89","title":"分布式ID"},{"parent":"a2bfaf42f759","children":[{"parent":"f742513252a5","children":[],"id":"13a1fb51f35c","title":"什么是分布式事务"},{"parent":"f742513252a5","children":[{"parent":"43ce55b67723","children":[{"parent":"a049777cc3e1","children":[],"id":"4969bca19609","title":"微服务的粒度变大一点，使得整个操作，都在一个数据库里面进行，这样就能保证ACID强一致性"}],"id":"a049777cc3e1","title":"微服务的划分粒度"}],"id":"43ce55b67723","title":"如何避免分布式事务"},{"parent":"f742513252a5","children":[{"parent":"f6707f730d62","children":[{"parent":"4e3ed064cc9a","children":[],"id":"c493ceb3a406","title":"事务开始"},{"parent":"4e3ed064cc9a","children":[{"parent":"b3c63fd4f25b","children":[{"parent":"deb5871d3bce","children":[],"id":"4b9f073680d4","title":"1.redo&nbsp;log通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。<br>2.undo用来回滚行记录到某个版本。undo&nbsp;log一般是逻辑日志，根据每行记录进行记录。"}],"id":"deb5871d3bce","title":"1.申请锁资源，对id=2这行数据上排他锁<br><br>2.将需要修改的data&nbsp;pages读取到innodb_buffer_cache<br><br>3.记录id=2的数据到undo&nbsp;log<br><br>4.记录id=2修改后的数据到redo&nbsp;log&nbsp;buffer<br><br>5.将buffer&nbsp;cache中id=2得name改为test<br>"}],"id":"b3c63fd4f25b","title":"准备提交事务（2PC的准备阶段）"},{"parent":"4e3ed064cc9a","children":[{"parent":"88f90ba31bc3","children":[],"id":"bfe821760cbb","title":"commit"},{"parent":"88f90ba31bc3","children":[],"id":"d3273fa6b796","title":"<b>如果一直没有commit，会怎样？？？</b><br><br><br>数据库断开连接会自动rollback<br>死锁或者锁超时也会自动rollback"}],"id":"88f90ba31bc3","title":"提交事务（2PC的doCommit阶段）"},{"parent":"4e3ed064cc9a","children":[],"id":"270f4a13480f","title":"事务结束"}],"boundaries":[{"boundary":true,"parent":"4e3ed064cc9a","boundRank":1,"children":[],"range":"1,2","style":{"lineType":"1","dasharray":"6,3","opacity":"0.1","lineWidth":"2"},"id":"a060f579b4cb","title":"外框"}],"id":"4e3ed064cc9a","title":"MySql的写操作<br>举例：update&nbsp;test&nbsp;set&nbsp;name&nbsp;=&nbsp;'test'&nbsp;where&nbsp;id=2;<br>"}],"id":"f6707f730d62","title":"事务的执行过程"},{"parent":"f742513252a5","children":[{"parent":"093abfa2c82e","children":[{"parent":"753d2ac94e6f","children":[{"parent":"26bf7e4dcd09","children":[{"parent":"65883972b5ca","image":{"w":399,"h":324,"url":"http://cdn.processon.com/6262249c7d9c0807247eb3fe?e=1650602668&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:eAxENxj12P5IzuZRq_EEnfku9yo=","direction":"up"},"children":[],"id":"0333850e9898","title":""}],"id":"65883972b5ca","title":"结构"},{"parent":"26bf7e4dcd09","children":[{"parent":"a0e2c770a39f","children":[],"id":"8cedc4247014","title":"1、该分布式系统中，存在一个节点作为协调者（Coordinator），其他节点作为参与者（Participants）。且节点之间可以进行网络通信。<br>2、所有节点都采用<b>预写式日志</b>，且日志被写入后即被保持在可靠的存储设备上，即使节点损坏不会导致日志数据的消失。<br>3、所有节点不会永久性损坏，即使损坏后仍然可以恢复。"}],"id":"a0e2c770a39f","title":"前提"},{"parent":"26bf7e4dcd09","children":[{"parent":"133341ed2439","children":[{"parent":"8a752fdf9791","children":[],"id":"a270f91ee5de","title":"协调各个参与者，对分布式事务进行提交或回滚"}],"id":"8a752fdf9791","title":"协调者"},{"parent":"133341ed2439","children":[{"parent":"f3baa51dfb30","children":[],"id":"534d2995149d","title":"分布式集群中的节点"}],"id":"f3baa51dfb30","title":"参与者"}],"id":"133341ed2439","title":"角色"},{"parent":"26bf7e4dcd09","children":[{"parent":"381f1c1ec61d","children":[{"parent":"0463462babba","children":[{"parent":"6405386522bc","children":[],"id":"b317edc5196d","title":"1、协调者节点向所有参与者节点询问是否可以执行提交操作，并开始等待各参与者节点的响应。<br>2、参与者节点执行询问发起为止的所有事务操作，并将<font color=\"#f44336\">Undo信息和Redo信息写入日志</font>。（也就是会执行事务，但不提交）<br>3、各参与者节点响应协调者节点发起的询问。<br>4、收到所有参与者节点的表决后，<br>&nbsp; &nbsp; &nbsp; 如果所有参与者节点的事务操作实际执行成功，则它返回一个\"同意\"消息；<br>&nbsp; &nbsp; &nbsp; 如果有一个参与者节点的事务操作实际执行失败，则它返回一个\"中止\"消息，<br><font color=\"#f44336\">协调者在发出准备提交信息前也要把有关信息写入自己的日志中</font><br><br>"}],"id":"6405386522bc","title":"过程"}],"id":"0463462babba","title":"表决阶段"},{"parent":"381f1c1ec61d","children":[{"parent":"0923ad8fac14","children":[{"parent":"7b4ff0798cfe","children":[{"parent":"e8dbf456ce0a","children":[],"id":"5b668dca2f9b","title":"当协调者节点从所有参与者节点获得的响应消息都为\"同意\"时：<br><br>1、协调者节点向所有参与者节点发出\"正式提交\"的请求。<br>2、参与者节点正式完成操作，并释放在整个事务期间内占用的资源。<br>3、参与者节点向协调者节点发送\"完成\"消息。<br>4、协调者节点收到所有参与者节点反馈的\"完成\"消息后，完成事务。"}],"id":"e8dbf456ce0a","title":"成功"},{"parent":"7b4ff0798cfe","children":[{"parent":"e4b82f58a736","children":[],"id":"80ad9de6c294","title":"如果任一参与者节点在第一阶段返回的响应消息为\"终止\"，或者协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：<br><br>1、协调者节点向所有参与者节点发出\"回滚操作\"的请求。<br>2、参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。<br>3、参与者节点向协调者节点发送\"回滚完成\"消息。<br>4、协调者节点收到所有参与者节点反馈的\"回滚完成\"消息后，取消事务。"}],"id":"e4b82f58a736","title":"失败"}],"id":"7b4ff0798cfe","title":"过程"}],"id":"0923ad8fac14","title":"doCommit阶段"},{"parent":"381f1c1ec61d","children":[{"parent":"460f182e429b","children":[{"parent":"09ba8cb1d1f7","children":[{"parent":"51f33715868e","children":[],"id":"1a4b761ab19e","title":"1.申请锁资源，对id=2这行数据上排他锁<br><br>2.将需要修改的data&nbsp;pages读取到innodb_buffer_cache<br><br>3.记录id=2的数据到<font color=\"#f44336\">undo&nbsp;log</font><br><br>4.记录id=2修改后的数据到<font color=\"#f44336\">redo&nbsp;log</font>&nbsp;buffer<br><br>5.将buffer&nbsp;cache中id=2得name改为test<br>"}],"id":"51f33715868e","title":"请求阶段"},{"parent":"09ba8cb1d1f7","children":[{"parent":"0445dfd4345a","children":[],"id":"fe08fd6eb101","title":"commit"}],"id":"0445dfd4345a","title":"doCommit阶段<br>"}],"id":"09ba8cb1d1f7","title":"update&nbsp;test&nbsp;set&nbsp;name&nbsp;=&nbsp;'test'&nbsp;where&nbsp;id=2;"}],"id":"460f182e429b","title":"举例"}],"collapsed":false,"boundaries":[{"boundary":true,"parent":"381f1c1ec61d","boundRank":1,"children":[],"range":"0,1","style":{"lineType":"1","dasharray":"6,3","opacity":"0.1","fill":"rgb(113, 203, 45)","lineWidth":"2"},"id":"2a59c56bc66b","title":"外框"}],"id":"381f1c1ec61d","title":"阶段"},{"parent":"26bf7e4dcd09","children":[{"parent":"1df586fe38cf","children":[],"id":"3603ffedf632","title":"表决阶段：除了事务提交，啥都做了"},{"parent":"1df586fe38cf","children":[],"id":"b1a8110483ab","title":"提交阶段：提交事务或者回滚事务"}],"id":"1df586fe38cf","title":"简述上面两个阶段"},{"parent":"26bf7e4dcd09","children":[{"parent":"971d8809fbcc","children":[{"parent":"6f16fd3437d2","children":[],"id":"ecebd38d772b","title":"第一阶段执行了准备命令后，我们每个本地资源都处于锁定状态，因为除了事务的提交之外啥都做了。\n\n所以这时候如果本地的其他请求要访问同一个资源，比如要修改商品表&nbsp;id&nbsp;等于&nbsp;100&nbsp;的那条数据，那么此时是被阻塞住的，必须等待前面事务的完结，收到提交/回滚命令执行完释放资源后，这个请求才能得以继续。\n\n所以假设这个分布式事务涉及到很多参与者，然后有些参与者处理又特别复杂，特别慢，那么那些处理快的节点也得等着，所以说效率有点低。"}],"style":{"background-color":"rgb(255, 83, 92)","border-radius":"6px","color":"rgb(255, 255, 255)","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"6f16fd3437d2","title":"节点阻塞"},{"parent":"971d8809fbcc","children":[{"parent":"32322ad06126","children":[],"id":"8e2dc0b70432","title":"参与者在投票之后，由于协调者发生崩溃或错误，而导致参与者处于无法知晓是否提交或者中止的“不确定状态”"}],"style":{"background-color":"rgb(255, 83, 92)","border-radius":"6px","color":"rgb(255, 255, 255)","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"32322ad06126","title":"协调者有单点故障问题"}],"id":"971d8809fbcc","title":"缺点"},{"parent":"26bf7e4dcd09","children":[{"parent":"5fa86e828945","children":[],"id":"e4a2102f8c9f","title":"Spring也有JTA的事务管理器。\n\nAtomikos、bitronix实现了JTA，它们只需要提供jar包就可以了。实现了XA协议的数据库或者消息队列，已经能够具备了准备、提交、回滚的各种能力。"}],"style":{"background-color":"rgb(80, 194, 139)","border-radius":"5px","color":"rgb(255, 255, 255)","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"5fa86e828945","title":"实现框架"}],"collapsed":true,"id":"26bf7e4dcd09","title":"两阶段提交协议（2PC/XA事务 -- 常用）<br>参考:https://zh.wikipedia.org/wiki/二阶段提交"},{"parent":"753d2ac94e6f","children":[{"parent":"c88209eca248","children":[{"parent":"b68784d36dd1","children":[],"id":"4a7fa2735782","title":"为了解决2PC的缺点而设计的"}],"id":"b68784d36dd1","title":"目的"},{"parent":"c88209eca248","children":[{"parent":"a776b7dd9d5e","children":[],"id":"11eaab7d204b","title":"https://baike.baidu.com/pic/%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/15978718/0/f7246b600c338744adfced4d5c0fd9f9d72aa0c2?fr=lemma&amp;ct=single#aid=0&amp;pic=f7246b600c338744adfced4d5c0fd9f9d72aa0c2"}],"id":"a776b7dd9d5e","title":"结构"},{"parent":"c88209eca248","children":[{"parent":"690daa6a9e61","children":[{"parent":"c4e8b50cc128","children":[{"parent":"4fcb105383af","children":[],"id":"72d186294c4e","title":"1、协调者节点向所有参与者节点询问是否可以执行事务，并开始等待各参与者节点的响应。<br>2、各参与者节点响应协调者节点发起的询问。<br>3、收到所有参与者节点的表决后，<br>&nbsp; &nbsp; &nbsp; 如果所有参与者节点的状态为同意，<font color=\"#f44336\">则进入第二阶段</font><br>&nbsp; &nbsp; &nbsp; 如果有一个参与者节点的状态为终止，<font color=\"#f44336\">则进入第三阶段</font><br>"}],"id":"4fcb105383af","title":"过程"}],"id":"c4e8b50cc128","title":"表决阶段"},{"parent":"690daa6a9e61","children":[{"parent":"0e48c1bb6a47","children":[{"parent":"319a7c366443","children":[],"id":"bbc9f277df1f","title":"1、由协调者发准备提交消息(Prepare&nbsp;to&nbsp;Commit)。<br><br>2、参与者节点执行询问发起为止的所有事务操作，并将<font color=\"#f44336\">Undo信息和Redo信息写入日志</font>。（也就是会执行事务，但不提交），并回答确认消息ACK。<br><br>3、收到所有参与者节点的执行结果后，<br>&nbsp; &nbsp; &nbsp; 如果所有参与者节点的事务操作实际执行成功，则它返回一个\"同意\"消息；<br>&nbsp; &nbsp; &nbsp; 如果有一个参与者节点的事务操作实际执行失败，则它返回一个\"中止\"消息，<br><font color=\"#f44336\">协调者在发出准备提交信息前也要把有关信息写入自己的日志中</font><br>"}],"id":"319a7c366443","title":"过程"}],"id":"0e48c1bb6a47","title":"preCommit阶段"},{"parent":"690daa6a9e61","children":[{"parent":"fe7e1c61a61d","children":[{"parent":"5161c82488e3","children":[{"parent":"1b48dc993900","children":[],"id":"119165bed9c3","title":"当协调者节点从所有参与者节点获得的响应消息都为\"同意\"时：<br><br>1、协调者节点向所有参与者节点发出\"正式提交\"的请求。<br>2、参与者节点正式完成操作，并释放在整个事务期间内占用的资源。<br>3、参与者节点向协调者节点发送\"完成\"消息。<br>4、协调者节点收到所有参与者节点反馈的\"完成\"消息后，完成事务。"}],"id":"1b48dc993900","title":"成功"},{"parent":"5161c82488e3","children":[{"parent":"b630da343c5a","children":[],"id":"f424bf7b61b2","title":"如果任一参与者节点在第一阶段返回的响应消息为\"终止\"，或者协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：<br><br>1、协调者节点向所有参与者节点发出\"回滚操作\"的请求。<br>2、参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。<br>3、参与者节点向协调者节点发送\"回滚完成\"消息。<br>4、协调者节点收到所有参与者节点反馈的\"回滚完成\"消息后，取消事务。"}],"id":"b630da343c5a","title":"失败"}],"id":"5161c82488e3","title":"过程"}],"id":"fe7e1c61a61d","title":"doCommit阶段"}],"collapsed":true,"boundaries":[{"boundary":true,"parent":"690daa6a9e61","boundRank":1,"children":[],"range":"0,2","style":{"lineType":"1","dasharray":"6,3","opacity":"0.1","fill":"rgb(113, 203, 45)","lineWidth":"2"},"id":"aa5f9a63b8c4","title":"外框"},{"boundary":true,"parent":"690daa6a9e61","boundRank":2,"children":[],"range":"0,1","style":{"lineType":"1","dasharray":"6,3","lineColor":"#939aa8","fill":"#bf1e1b","opacity":"0.1","lineWidth":"2"},"id":"f09c985ec6be","title":"外框"}],"id":"690daa6a9e61","title":"阶段<br>"},{"parent":"c88209eca248","children":[{"parent":"730947327e83","children":[],"id":"8afdbe7f128d","title":"表决阶段单纯就是协调者去访问参与者，类似于你还好吗？能接请求不。<br>"},{"parent":"730947327e83","children":[],"id":"2f6dbfafe2b1","title":"preCommit阶段其实就是&nbsp;2PC&nbsp;的表决阶段，除了事务的提交啥都干了。<br>"},{"parent":"730947327e83","children":[],"id":"d31fc36047c7","title":"doCommit阶段和&nbsp;2PC&nbsp;的提交一致。"}],"id":"730947327e83","title":"简述上面三个阶段"},{"parent":"c88209eca248","children":[{"parent":"768f6601049c","children":[],"id":"85c86d3858aa","title":"虽能避免阻塞状态，但需要更多的通讯次数，实现比较复杂。因此实际应用较少。大多数使用一致性提交协议的系统都采用二阶段提交协议。"}],"id":"768f6601049c","title":"缺点"},{"parent":"c88209eca248","children":[{"parent":"9b245e20a2d7","children":[],"id":"1347237f80d1","title":"三段提交协议的优点：能避免阻塞状态，在三段提交协议中，如果协调者在第二段之后失效，不会产生像2PC协议中可能出现的事务阻塞现象。因为下面两种状态至少存在一种：<br>1、所有参与者都进入Prepare&nbsp;to&nbsp;Commit状态，事务可以安全地提交。因为所有参与者都回答了ACK确认消息。<br>2、至少有一个参与者未进入Prepare&nbsp;to&nbsp;Commit状态，事务可以安全回滚。因为至少有一个参与者未回答ACK确认消息，则协调者也不会发出Globle-Commit命令。"}],"id":"9b245e20a2d7","title":"优点"}],"collapsed":true,"id":"c88209eca248","title":"三阶段提交协议（3PC）<br>参考：https://baike.baidu.com/item/三阶段提交/15978718"}],"id":"753d2ac94e6f","title":"强一致性（CP模式）"},{"parent":"093abfa2c82e","children":[{"parent":"71ba7f095051","children":[{"parent":"704ae570e51a","children":[{"parent":"d7514e823054","children":[{"parent":"5c21d36a9ebb","children":[],"id":"cd817edf3c6a","title":"Try"},{"parent":"5c21d36a9ebb","children":[],"id":"eb291eb23a40","title":"Commit"},{"parent":"5c21d36a9ebb","children":[],"id":"b4bf8d775527","title":"Cancel"}],"id":"5c21d36a9ebb","title":"通用TCC"},{"parent":"d7514e823054","children":[],"id":"16c7c8cd635b","title":"没有Try的TCC"},{"parent":"d7514e823054","children":[],"id":"879582f54897","title":"异步型TCC"}],"id":"d7514e823054","title":"分类"},{"parent":"704ae570e51a","children":[],"id":"a978fcddf59d","title":"http://www.bytesoft.org/how-to-impl-tcc/"},{"parent":"704ae570e51a","children":[{"parent":"2554792a3b30","children":[],"id":"f7e9a537f0ee","title":"使用2PC机制时————以提交为例————一个完整的事务生命周期是：begin&nbsp;-&gt;&nbsp;业务逻辑&nbsp;-&gt;&nbsp;prepare&nbsp;-&gt;&nbsp;commit<br>使用TCC机制时————以提交为例————一个完整的事务生命周期是：begin&nbsp;-&gt;&nbsp;业务逻辑(try业务)&nbsp;-&gt;&nbsp;commit(comfirm业务)<br>"},{"parent":"2554792a3b30","children":[{"parent":"71b8e38a289f","children":[],"id":"c4ad8869d99b","title":"我们可以从执行的阶段上将二者一一对应起来：<br>1、&nbsp;2PC机制的业务阶段&nbsp;等价于&nbsp;TCC机制的try业务阶段；<br>2、&nbsp;2PC机制的提交阶段（prepare&nbsp;&amp;&nbsp;commit）&nbsp;等价于&nbsp;TCC机制的提交阶段（confirm）；<br>3、&nbsp;2PC机制的回滚阶段（rollback）&nbsp;等价于&nbsp;TCC机制的回滚阶段（cancel）。<br><br>因此，可以看出，虽然TCC机制中有两个阶段都存在业务逻辑的执行，但<b>其中try业务阶段其实是与全局事务处理无关的</b>。认清了这一点，当我们再比较TCC和2PC时，就会很容易地发现，TCC不是两阶段提交，而只是它对事务的提交/回滚是通过执行一段confirm/cancel业务逻辑来实现，仅此而已。<br><br>作者：小黑哎代码<br>链接：https://juejin.cn/post/6844903951477768205<br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br>"}],"id":"71b8e38a289f","title":"结论<br>"}],"collapsed":false,"id":"2554792a3b30","title":"TCC和2PC区别"},{"parent":"704ae570e51a","children":[{"parent":"6867659ccdca","children":[],"id":"a1871f9935c4","title":"spring-cloud-rest-tcc、ByteTCC、tcc-transaction、seata等。"}],"style":{"background-color":"rgb(80, 194, 139)","border-radius":"5px","color":"rgb(255, 255, 255)","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"6867659ccdca","title":"实现框架"}],"collapsed":true,"id":"704ae570e51a","title":"TCC分段提交"},{"parent":"71ba7f095051","children":[{"parent":"37aab287efef","children":[],"id":"eed3142f877c","title":"kafka"},{"parent":"37aab287efef","children":[{"parent":"345667aa495a","children":[],"id":"f3eb50d0e628","title":"https://juejin.cn/post/6953986394549305374#heading-18"}],"id":"345667aa495a","title":"RabbitMQ"},{"parent":"37aab287efef","children":[],"id":"a6ff1bf74975","title":"RocketMQ"}],"style":{"background-color":"rgb(80, 194, 139)","border-radius":"5px","color":"rgb(255, 255, 255)","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"37aab287efef","title":"基于消息队列的最终一致性设计（常用）"},{"parent":"71ba7f095051","children":[],"id":"bde728d69545","title":"不要求最终一致性的柔性事务<br>"}],"id":"71ba7f095051","title":"最终一致性（AP模式）"}],"collapsed":false,"id":"093abfa2c82e","title":"解决方案"},{"parent":"f742513252a5","children":[{"parent":"b40b9911917d","children":[{"parent":"9b8c0b490403","children":[],"id":"b2d62f7ba0cd","title":"AT模式"},{"parent":"9b8c0b490403","children":[],"id":"ebb1f98517af","title":"TCC模式"},{"parent":"9b8c0b490403","children":[],"id":"1ce41bd34597","title":"saga模式"}],"id":"9b8c0b490403","title":"seata"},{"parent":"b40b9911917d","children":[],"id":"ad7aa2336c15","title":"Spring-JTA（基于2PC协议）"}],"id":"b40b9911917d","title":"分布式事务框架"}],"collapsed":false,"id":"f742513252a5","title":"分布式事务"}],"collapsed":false,"style":{"background-color":"rgb(80, 194, 139)","border-radius":"5px","color":"rgb(255, 255, 255)","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"a2bfaf42f759","title":"数据库"},{"parent":"520e70c58b6f","children":[{"parent":"fcb5dba6c488","children":[],"id":"d8710d8ec9be","title":"举例：Redis、Memcache"},{"parent":"fcb5dba6c488","children":[{"parent":"2fcdb5e0565e","children":[{"parent":"4ebcb6f6e3c2","children":[],"id":"eb1d97fc3a20","title":"redis无法保证CP，因为redis的主从同步机制是异步的"},{"parent":"4ebcb6f6e3c2","children":[{"parent":"77523177690c","children":[],"id":"045c3ed0c30c","title":"主从架构、哨兵模式"}],"id":"77523177690c","title":"AP"}],"id":"4ebcb6f6e3c2","title":"从CAP理论分析，如何让kafka保证AP、CP"}],"id":"2fcdb5e0565e","title":"Redis"},{"parent":"fcb5dba6c488","children":[],"id":"46da7148bf69","title":"缓存、数据库双写一致性问题"},{"parent":"fcb5dba6c488","children":[],"id":"28ddd801963b","title":"缓存雪崩"},{"parent":"fcb5dba6c488","children":[],"id":"2a0ca9cc907f","title":"缓存穿透"},{"parent":"fcb5dba6c488","children":[],"id":"79e8686e0a9a","title":"缓存击穿"},{"parent":"fcb5dba6c488","children":[],"id":"d7e53b9ae4ce","title":"缓存预热"}],"style":{"background-color":"rgb(80, 194, 139)","border-radius":"5px","color":"rgb(255, 255, 255)","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"fcb5dba6c488","title":"缓存"},{"parent":"520e70c58b6f","children":[{"parent":"744898601ca7","children":[],"id":"a4a5a9d86f84","title":"举例：kafka、ActivityMQ"},{"parent":"744898601ca7","children":[{"parent":"b65521ab832e","children":[{"parent":"01469d81eac5","children":[],"id":"c95ab10707cd","title":"如何保证HA高可用（AP模式）"},{"parent":"01469d81eac5","children":[],"id":"b128afe1c3c1","title":"消息丢失（消息一致性问题，CP模式）"}],"style":{"background-color":"rgb(80, 194, 139)","border-radius":"5px","color":"rgb(255, 255, 255)","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"01469d81eac5","title":"从CAP理论分析，如何让kafka保证AP、CP"}],"id":"b65521ab832e","title":"kafka"},{"parent":"744898601ca7","children":[{"parent":"e0e461e30931","children":[],"id":"762387405550","title":"单播"},{"parent":"e0e461e30931","children":[],"id":"29d0e73b2ee2","title":"广播"}],"id":"e0e461e30931","title":"订阅模式"},{"parent":"744898601ca7","children":[{"parent":"1a923a02adb1","children":[],"id":"af56d1be577d","title":"过期时间"},{"parent":"1a923a02adb1","children":[],"id":"e150dba08c3b","title":"死信"}],"id":"1a923a02adb1","title":"特性"},{"parent":"744898601ca7","children":[{"parent":"cf9305d48921","children":[],"id":"1ba73171b904","title":"延时消费"},{"parent":"cf9305d48921","children":[],"id":"93fffe637883","title":"延时重试"},{"parent":"cf9305d48921","children":[{"parent":"b9f4c00209ac","children":[{"parent":"729af8e79e93","children":[{"parent":"d7f593d8cb79","children":[],"id":"df102a585119","title":"https://blog.csdn.net/m0_45406092/article/details/119564881"}],"id":"d7f593d8cb79","title":"kafka&nbsp;producer消息发送机制"},{"parent":"729af8e79e93","children":[{"parent":"cbeee8d337bc","children":[],"id":"4a6522baf3e1","title":"方案一：消息的发送应该变为同步，A发送请求，得到成功响应后，再发送B。<br><br>也会存在问题，如果A进入队列后，再发送B的时候，web服务宕机了，但是消息已经在队列中，这种请款该如何处理"},{"parent":"cbeee8d337bc","children":[],"id":"67274cc269ed","title":"方案二：kafka是否支持一个请求写入多个消息？？？？，这样就能保证原子性"}],"id":"cbeee8d337bc","title":"AB请求需要顺序处理，<b>AB同时异步发送请求</b>，A发送请求失败，B发送请求成功，B进入队列，A重试后进入队列，队列里面的任务顺序为BA，根据队列的先进先出原理，消费顺序变成BA，就会出错"}],"id":"729af8e79e93","title":"生产有序"},{"parent":"b9f4c00209ac","children":[{"parent":"1c3eea97c016","children":[{"parent":"c5dbc2c991ae","children":[],"id":"b43b5ad5b58b","title":"https://www.cnblogs.com/yisany/p/14736360.html"}],"id":"c5dbc2c991ae","title":"如何保证AB任务都在同一个patition"}],"id":"1c3eea97c016","title":"进入队列"},{"parent":"b9f4c00209ac","children":[{"parent":"14fb12f9025e","children":[{"parent":"b338756b1aa5","children":[],"id":"f7b8e1e50b8c","title":"如何AB被两个线程分别消费，这个顺序就得不到保障。<br>如果能够指定某个线程来消费，单线程中，消费就是有序的"}],"id":"b338756b1aa5","title":"通常消息都是对接线程池进行消费，如何保证有序性"}],"id":"14fb12f9025e","title":"消费有序"}],"style":{"background-color":"rgb(80, 194, 139)","border-radius":"5px","color":"rgb(255, 255, 255)","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"b9f4c00209ac","title":"如何保证消息有序消费"},{"parent":"cf9305d48921","children":[],"style":{"background-color":"rgb(80, 194, 139)","border-radius":"5px","color":"rgb(255, 255, 255)","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"b08a797622c3","title":"如何保证不会有重复消息"},{"parent":"cf9305d48921","children":[{"parent":"7155c4285e8a","children":[],"id":"9f29ffb380aa","title":"产出 &gt; 消费"}],"id":"7155c4285e8a","title":"消息堆积"}],"id":"cf9305d48921","title":"业务问题"}],"style":{"background-color":"rgb(80, 194, 139)","border-radius":"5px","color":"rgb(255, 255, 255)","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"744898601ca7","title":"消息"},{"parent":"520e70c58b6f","children":[],"style":{"background-color":"rgb(80, 194, 139)","border-radius":"5px","color":"rgb(255, 255, 255)","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"bc0405f44453","title":"日志"},{"parent":"520e70c58b6f","children":[{"parent":"60a145245f33","children":[{"parent":"7725a40d8200","children":[{"parent":"15440da1f3cb","children":[{"parent":"08e1da1b37a4","children":[],"id":"186cb5c075d3","title":"增"},{"parent":"08e1da1b37a4","children":[],"id":"51548e3f227f","title":"删"},{"parent":"08e1da1b37a4","children":[],"id":"48aad32899dd","title":"改"}],"id":"08e1da1b37a4","title":"多个客户端，对同一资源的操作"}],"id":"15440da1f3cb","title":"场景"},{"parent":"7725a40d8200","children":[{"parent":"f0904da8fae5","children":[{"parent":"727d1ff3abb1","children":[{"parent":"ef29c0002c8b","children":[],"id":"3a2b975939c3","title":"看门狗机制，redission已实现"}],"id":"ef29c0002c8b","title":"问题1：如果业务处理时间 &gt; 锁的超时时间，锁提前释放了，这种情况怎么预防？？？"},{"parent":"727d1ff3abb1","children":[{"parent":"d7e8e8896a9a","children":[],"id":"b8e23585ef4e","title":"设置最大续命次数"}],"id":"d7e8e8896a9a","title":"问题2：在设置看门狗后，因为业务处理出现问题，造成了死循环，导致锁一直续命，得不到释放，后续的业务就不能继续执行。这种改怎么处理。"}],"id":"727d1ff3abb1","title":"设置超时时间"},{"parent":"f0904da8fae5","children":[{"parent":"c7e7897eab56","children":[{"parent":"9c5568b1f7c5","children":[],"id":"62ed9f03baec","title":"redlock算法，redission已实现"}],"id":"9c5568b1f7c5","title":"单机如果宕机，就会造成业务问题；常规方式，我们可以搞个从机，主从架构。但是主从架构真的能够解决问题吗？<br><br>因为redis的主从同步是异步的：<br>在这种场景（主从结构）中存在明显的竞态:<br><br>客户端A从master获取到锁<br>在master将锁同步到slave之前，master宕掉了。<br>slave节点被晋级为master节点<br>客户端B取得了同一个资源被客户端A已经获取到的另外一个锁。安全失效！<br>"}],"id":"c7e7897eab56","title":"单点问题"}],"collapsed":true,"id":"f0904da8fae5","title":"创建分布式锁注意事项<br>http://www.redis.cn/topics/distlock.html<br>"},{"parent":"7725a40d8200","children":[{"parent":"32d2490fc5c0","children":[{"parent":"15800a582f06","children":[],"id":"e99cea75d9d2","title":"框架：redission"}],"style":{"background-color":"rgb(80, 194, 139)","border-radius":"5px","color":"rgb(255, 255, 255)","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"15800a582f06","title":"redis（CAP理论中的AP模式，redis的主从同步是异步的）"},{"parent":"32d2490fc5c0","children":[{"parent":"41a33a9d81a1","children":[],"id":"d60dbe3d412e","title":"没用过"}],"style":{"background-color":"rgb(80, 194, 139)","border-radius":"5px","color":"rgb(255, 255, 255)","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"41a33a9d81a1","title":"zookeeper（CAP理论中CP模式，zookeeper是CP模式）"}],"collapsed":true,"id":"32d2490fc5c0","title":"方案实现<br>https://blog.csdn.net/fuzhongmin05/article/details/121541139<br>"}],"collapsed":false,"id":"7725a40d8200","title":"分布式锁"},{"parent":"60a145245f33","children":[{"parent":"b644b24c6f4c","children":[{"parent":"23c05f3dea94","children":[{"parent":"c1667c3e5dc2","children":[],"id":"6e0759d36bdf","title":"阶梯重试（5s、30s等），注意接口的幂等性"}],"id":"c1667c3e5dc2","title":"方案"}],"id":"23c05f3dea94","title":"请求超时；客户端发送请求，服务器端迟迟未收到"},{"parent":"b644b24c6f4c","children":[],"id":"4db44af7d74b","title":"服务端内部调用超时；客户端发送请求，服务器端中微服务之间调用超时"},{"parent":"b644b24c6f4c","children":[],"id":"9569bad1eea0","title":"响应超时；客户端发送请求，服务器端收到，整体处理时间超时"}],"id":"b644b24c6f4c","title":"服务调用的超时问题？？？？"}],"style":{"background-color":"rgb(80, 194, 139)","border-radius":"5px","color":"rgb(255, 255, 255)","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"60a145245f33","title":"应用"},{"parent":"520e70c58b6f","children":[],"id":"b9e6f84f9357","title":"监控"},{"parent":"520e70c58b6f","children":[],"id":"c7b13e52db60","title":"账本"}],"boundaries":[{"boundary":true,"parent":"520e70c58b6f","boundRank":1,"children":[],"pos":{"miny":7176,"minx":10342,"maxY":10028,"maxX":12668},"range":"2,6","style":{"lineType":"1","dasharray":"6,3","opacity":"0.1","lineWidth":"2"},"id":"fc6acc9b2378","title":"外框"}],"id":"520e70c58b6f","title":"场景分类<br>（以下所有场景都可以围绕CAP理论讨论）"},{"parent":"root","lineStyle":{"randomLineColor":"#80BA4C"},"children":[{"parent":"d96407951df1","children":[{"parent":"ab0dfb2f8cdf","children":[{"parent":"5a15c24f53e2","children":[],"id":"1c6ea2b7eb66","title":"应用扩容"},{"parent":"5a15c24f53e2","children":[],"id":"4f2635abd3bf","title":"机器下线"},{"parent":"5a15c24f53e2","children":[],"id":"c17236d85c72","title":"机器置换"}],"id":"5a15c24f53e2","title":"弹性伸缩"},{"parent":"ab0dfb2f8cdf","children":[{"parent":"1c1409d2145f","children":[],"id":"b29f9c5544bb","title":"域名申请"},{"parent":"1c1409d2145f","children":[],"id":"f5e9a41e8f5e","title":"域名变更"},{"parent":"1c1409d2145f","children":[],"id":"3ba2bd5e7cd8","title":"负载管理"},{"parent":"1c1409d2145f","children":[],"id":"d483fdaed3b1","title":"安全外联"},{"parent":"1c1409d2145f","children":[],"id":"9e8f819061ea","title":"统一接入"}],"id":"1c1409d2145f","title":"网络管理"},{"parent":"ab0dfb2f8cdf","children":[{"parent":"8c2f3987affc","children":[],"id":"44faa2452b83","title":"现场保留"},{"parent":"8c2f3987affc","children":[],"id":"eaf14ee84f23","title":"调试接入"}],"id":"8c2f3987affc","title":"故障快照"}],"id":"ab0dfb2f8cdf","title":"资源调度"},{"parent":"d96407951df1","children":[{"parent":"fe439a64f68a","children":[{"parent":"9a4b239b1b5b","children":[],"id":"6aca07c6f4f0","title":"交换机"},{"parent":"9a4b239b1b5b","children":[],"id":"fcfdb8bff9da","title":"LVS"},{"parent":"9a4b239b1b5b","children":[],"id":"e2efea8eddbc","title":"Nginx"},{"parent":"9a4b239b1b5b","children":[{"parent":"888171bdec8e","children":[],"id":"ffd6a971323b","title":"轮询"},{"parent":"888171bdec8e","children":[],"id":"4e0620c8c3c9","title":"权重"},{"parent":"888171bdec8e","children":[],"id":"ded654c93586","title":"IP"},{"parent":"888171bdec8e","children":[],"id":"993dc0912fad","title":"随机"},{"parent":"888171bdec8e","children":[],"id":"2be4a2004353","title":"最空闲连接策略"}],"id":"888171bdec8e","title":"负载均衡算法"}],"boundaries":[{"boundary":true,"parent":"9a4b239b1b5b","boundRank":1,"children":[],"range":"3,3","style":{"lineType":"1","dasharray":"6,3","opacity":"0.1","lineWidth":"2"},"id":"a192fbd67138","title":"外框"}],"id":"9a4b239b1b5b","title":"负载均衡"},{"parent":"fe439a64f68a","children":[{"parent":"4f647b50da8f","children":[],"id":"8b5f0db5a20b","title":"高性能"},{"parent":"4f647b50da8f","children":[],"id":"3afe81da061e","title":"分布式"},{"parent":"4f647b50da8f","children":[],"id":"5adac081b755","title":"业务筛选"}],"id":"4f647b50da8f","title":"网关设计"},{"parent":"fe439a64f68a","children":[{"parent":"33aa9de61350","children":[{"parent":"407fd77d264f","children":[],"id":"af2c509fdb5d","title":"流量清洗/请求鉴权"}],"id":"407fd77d264f","title":"请求校验"},{"parent":"33aa9de61350","children":[{"parent":"7b63dd335858","children":[],"id":"3aa1c9643f32","title":"CDN"}],"id":"7b63dd335858","title":"数据缓存"}],"id":"33aa9de61350","title":"流量管理"},{"parent":"fe439a64f68a","children":[{"parent":"42a3e5a79fb2","children":[{"parent":"70f940569c3b","children":[],"id":"b8f28fcf3b0e","title":"计数器"},{"parent":"70f940569c3b","children":[],"id":"68ad42e05d29","title":"队列"},{"parent":"70f940569c3b","children":[],"id":"4148520d23af","title":"漏斗"},{"parent":"70f940569c3b","children":[],"style":{"background-color":"rgb(80, 194, 139)","border-radius":"5px","color":"rgb(255, 255, 255)","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"d35ed15e0f06","title":"令牌桶"},{"parent":"70f940569c3b","children":[],"id":"0e5bf028a49b","title":"动态流控"}],"boundaries":[],"id":"70f940569c3b","title":"流量分配算法"},{"parent":"42a3e5a79fb2","children":[{"parent":"a7c71ffe98b9","children":[{"parent":"92856815d51d","children":[],"id":"5ec4ee30d44d","title":"QPS粒度"},{"parent":"92856815d51d","children":[],"id":"a284571c3a63","title":"线程数粒度"},{"parent":"92856815d51d","children":[],"id":"19aa2774871d","title":"RT阈值"}],"id":"92856815d51d","title":"限流策略"},{"parent":"a7c71ffe98b9","children":[{"parent":"200d730cf59c","children":[],"id":"ebebb3965ad3","title":"SENTINEL"}],"id":"200d730cf59c","title":"限流工具"}],"id":"a7c71ffe98b9","title":"流量限制"}],"boundaries":[{"boundary":true,"parent":"42a3e5a79fb2","boundRank":1,"children":[],"range":"0,0","style":{"lineType":"1","dasharray":"6,3","opacity":"0.1","lineWidth":"2"},"id":"dc104a7f41cc","title":"外框"}],"id":"42a3e5a79fb2","title":"流量控制"}],"id":"fe439a64f68a","title":"流量调度"},{"parent":"d96407951df1","children":[{"parent":"2a6871c69a20","children":[{"parent":"3c7b66b9be71","children":[],"id":"8b5856e4ac56","title":"状态类型"},{"parent":"3c7b66b9be71","children":[],"id":"402d731d56af","title":"生命周期"}],"id":"3c7b66b9be71","title":"注册中心"},{"parent":"2a6871c69a20","children":[{"parent":"5b81c2460b38","children":[],"id":"9f23f337ab98","title":"集群版本"},{"parent":"5b81c2460b38","children":[],"id":"774b252e3cc5","title":"版本回滚"}],"id":"5b81c2460b38","title":"版本管理"},{"parent":"2a6871c69a20","children":[{"parent":"99958a034fdf","children":[],"id":"1d527ccc0baa","title":"K8S"},{"parent":"99958a034fdf","children":[{"parent":"15c9871c362b","children":[],"id":"9550dc24c1d8","title":"HSF"},{"parent":"15c9871c362b","children":[],"id":"564d57d48307","title":"ZK + dubble"}],"id":"15c9871c362b","title":"springcloud"}],"id":"99958a034fdf","title":"服务编排"},{"parent":"2a6871c69a20","children":[{"parent":"c8db70e5f66b","children":[{"parent":"ab9e9da9ab44","children":[],"id":"afa9a3546f5e","title":"网关"},{"parent":"ab9e9da9ab44","children":[],"id":"63852f6f3f44","title":"健康检查"}],"id":"ab9e9da9ab44","title":"发现"},{"parent":"c8db70e5f66b","children":[{"parent":"851534570404","children":[],"id":"6ee4f94c4db6","title":"降低一致性"},{"parent":"851534570404","children":[],"id":"6eff3d0b866b","title":"关闭非核心业务"},{"parent":"851534570404","children":[],"id":"50a897110961","title":"简化功能"}],"id":"851534570404","title":"降级"},{"parent":"c8db70e5f66b","children":[{"parent":"9a8927c881af","children":[],"id":"f6c9df474d97","title":"闭合状态"},{"parent":"9a8927c881af","children":[],"id":"83d085982fa3","title":"断开状态"},{"parent":"9a8927c881af","children":[],"id":"576a93543605","title":"半开状态"},{"parent":"9a8927c881af","children":[],"id":"c7dd3bc1b394","title":"Hystrix"}],"id":"9a8927c881af","title":"熔断"},{"parent":"c8db70e5f66b","children":[{"parent":"95b77fe0fc49","children":[],"id":"63e250abae1f","title":"一致性哈希"},{"parent":"95b77fe0fc49","children":[],"id":"b67ca3165879","title":"snowflake"}],"id":"95b77fe0fc49","title":"幂等"}],"boundaries":[{"boundary":true,"parent":"c8db70e5f66b","boundRank":1,"children":[],"range":"3,3","style":{"lineType":"1","dasharray":"6,3","opacity":"0.1","lineWidth":"2"},"id":"2b9f6a7aeed7","title":"外框"}],"id":"c8db70e5f66b","title":"服务控制"}],"id":"2a6871c69a20","title":"服务调度"},{"parent":"d96407951df1","children":[{"parent":"1cad077cf93e","children":[],"id":"fd6977bbc947","title":"状态转移"},{"parent":"1cad077cf93e","children":[],"id":"f7483992b976","title":"分库分表"},{"parent":"1cad077cf93e","children":[],"id":"9ece6fc7abc2","title":"分区分片"}],"id":"1cad077cf93e","title":"数据调度"},{"parent":"d96407951df1","children":[{"parent":"2b80f54ee6bc","children":[{"parent":"6be8942ec75d","children":[],"id":"cf15061b16bd","title":"switch"},{"parent":"6be8942ec75d","children":[],"id":"54d9e64bccd6","title":"diamend"}],"id":"6be8942ec75d","title":"配置中心"},{"parent":"2b80f54ee6bc","children":[{"parent":"ec01ab095518","children":[],"id":"6ac17d04267e","title":"停机部署"},{"parent":"ec01ab095518","children":[],"id":"e50820d3fb0e","title":"滚动部署"},{"parent":"ec01ab095518","children":[],"id":"09514775036d","title":"蓝绿部署"},{"parent":"ec01ab095518","children":[],"id":"4a8dc92679d9","title":"灰度部署"}],"id":"ec01ab095518","title":"部署策略"},{"parent":"2b80f54ee6bc","children":[{"parent":"407be53888e4","children":[],"id":"8ca0261ef2bd","title":"schedulerX"},{"parent":"407be53888e4","children":[],"id":"06332af66df4","title":"spring-cloud-scheduler"}],"id":"407be53888e4","title":"作业调度"},{"parent":"2b80f54ee6bc","children":[{"parent":"7570054a3930","children":[],"id":"4145a5b1284b","title":"应用重启"},{"parent":"7570054a3930","children":[],"id":"5331b0c6df30","title":"应用下线"},{"parent":"7570054a3930","children":[],"id":"9e7cc6b97215","title":"日志清理"}],"id":"7570054a3930","title":"应用管理"}],"id":"2b80f54ee6bc","title":"自动运维"},{"parent":"d96407951df1","children":[{"parent":"47eca57aca9c","children":[],"id":"80fefea5b3fc","title":"补偿事务"},{"parent":"47eca57aca9c","children":[{"parent":"289d2f1e5946","children":[],"id":"6b55755af8e1","title":"spring-retry"}],"id":"289d2f1e5946","title":"重试设计"}],"id":"47eca57aca9c","title":"容错处理"},{"parent":"d96407951df1","children":[{"parent":"cf1258dd8e03","children":[{"parent":"60fcdf23634f","children":[],"id":"869cf8368977","title":"CPU"},{"parent":"60fcdf23634f","children":[],"id":"d86079549cb2","title":"IO"},{"parent":"60fcdf23634f","children":[],"id":"2135b3ade125","title":"内存"},{"parent":"60fcdf23634f","children":[],"id":"8da8710b63e9","title":"吞吐"},{"parent":"60fcdf23634f","children":[],"id":"332325f80dc6","title":"zprofile"}],"id":"60fcdf23634f","title":"基础层"},{"parent":"cf1258dd8e03","children":[{"parent":"3a0dfaf0ad92","children":[],"id":"393be2e4c84d","title":"各端中间件"},{"parent":"3a0dfaf0ad92","children":[],"id":"e6b5d7108ca5","title":"容器"},{"parent":"3a0dfaf0ad92","children":[],"id":"31cac2e7dd74","title":"GOC"}],"id":"3a0dfaf0ad92","title":"中间件"},{"parent":"cf1258dd8e03","children":[{"parent":"ba636d9d248e","children":[],"id":"d15d5d41f20a","title":"性能监控"},{"parent":"ba636d9d248e","children":[],"id":"9936e7f5033f","title":"业务监控"}],"id":"ba636d9d248e","title":"应用层"},{"parent":"cf1258dd8e03","children":[{"parent":"8e5f8992e202","children":[],"id":"83f3149b0416","title":"GOC"},{"parent":"8e5f8992e202","children":[],"id":"d4f4ca71b6fe","title":"SL5"},{"parent":"8e5f8992e202","children":[],"id":"3006781aa1ec","title":"Allimonitor"},{"parent":"8e5f8992e202","children":[],"id":"52b1f0b796fc","title":"Zipkin"}],"id":"8e5f8992e202","title":"监控链路"}],"id":"cf1258dd8e03","title":"全栈监控"},{"parent":"d96407951df1","children":[{"parent":"2a2514b674fb","children":[],"id":"2bc86fe4759b","title":"应用回滚"},{"parent":"2a2514b674fb","children":[],"id":"28be7b8a9834","title":"代码基线回退"},{"parent":"2a2514b674fb","children":[],"id":"44263a81ae8c","title":"版本回滚"}],"id":"2a2514b674fb","title":"故障恢复"},{"parent":"d96407951df1","children":[{"parent":"165e73299e17","children":[],"id":"22c5bb34bda3","title":"分布式锁应用"},{"parent":"165e73299e17","children":[],"id":"6979dbf8b2ee","title":"高并发"},{"parent":"165e73299e17","children":[],"id":"4cff9e0a0584","title":"异步"}],"id":"165e73299e17","title":"性能调优"}],"id":"d96407951df1","title":"工程应用"},{"parent":"root","lineStyle":{"randomLineColor":"#7549C5"},"children":[{"parent":"2ffc924dfaa1","children":[],"id":"6b7849ba410a","title":"01<br>CSS剪辑路径生成器（CSS&nbsp;clip-path&nbsp;maker）<br><br>02<br>新拟态风格（Neumorphism）<br><br>03<br>形状分割线（Shape&nbsp;Dividers）<br><br>04<br>生成SVG波浪（Generate&nbsp;SVG&nbsp;Waves）<br><br>05<br>Stylie<br><br>06<br>按需CSS动画（Animista）<br><br>07<br>CSS动画（cssanimation）<br><br>08<br>制作丝滑的贝塞尔曲线（Easings-&nbsp;Generate&nbsp;Cubic&nbsp;Bezier&nbsp;Easing&nbsp;Curves）<br><br>"}],"pos":{"x":8070,"y":10469},"id":"2ffc924dfaa1","title":"前端样式生成","free":true},{"parent":"root","lineStyle":{"randomLineColor":"#02ACF4"},"children":[{"parent":"2fde316dfeec","children":[{"parent":"f4b1f0c8d855","children":[],"id":"4a01da22edc0","title":"通读PMBOK第六版 --&gt;《汪博士解读PMP考试》打基础&nbsp;--&gt;&nbsp;小程序刷题找感觉&nbsp;--&gt;&nbsp;PMBOK查漏补缺&nbsp;--&gt;&nbsp;总结套路考前冲刺&nbsp;--&gt;&nbsp;ITTO死记硬背"}],"id":"f4b1f0c8d855","title":"学习路径"},{"parent":"2fde316dfeec","children":[{"parent":"bf60edb91c15","children":[],"id":"539ce3ce903e","title":"PMP考试在国内一年开展四次，分别在每年的3月、6月、9月、12月，"},{"parent":"bf60edb91c15","children":[],"id":"4f58ab1652e8","title":"每次考试时间会在周六的9.：00-12：50，180题，共230分钟（并且考场会提供零食和水）"}],"id":"bf60edb91c15","title":"时间"},{"parent":"2fde316dfeec","children":[{"parent":"b47252dabf9f","children":[{"parent":"8f501d4f4002","children":[],"id":"65f8a3e92fe4","title":"以往的单选题，经常问“首先该做什么”，这种时候就是考“过程”，根据过程的输入输出来确认怎么做。新考纲中这种问法比较少，更多的是问“怎么做来解决/规避问题”，这就要求你选最有效的步骤，而这个步骤在过程里可能不是最先要做的。<br><br>新考纲中也有考“过程”的，但选项很少直接给出过程名称的，取而代之的是描述某过程中具体怎么做。这样是可以根据逻辑关系推断选哪个，而不用死记硬背ITTO。<br>"}],"id":"8f501d4f4002","title":"单选题"},{"parent":"b47252dabf9f","children":[{"parent":"befabcf8ea50","children":[],"id":"a70faca5b8c7","title":"多选题我认为是最难的题型。首先题目会明确告诉你要选2项还是3项。多选题常见于情景题，在多个选项中，一般很容易选择最优的选项，通常是本知识领域中最贴合的过程或技术。但次优选项就比较纠结了，都是跨知识领域的，你感觉都不太贴合（这是刷单选题刷出来的硬性逻辑）。要想做好多选题，需要在学习过程中，要将不同知识领域/过程联合起来理解。"}],"id":"befabcf8ea50","title":"多选题"},{"parent":"b47252dabf9f","children":[{"parent":"127d68772d14","children":[],"id":"c3235ea8322d","title":"一般是多个场景与多种措施，要求你一一匹配起来。感觉难度不大，多花点时间就能做出最佳匹配。"}],"id":"127d68772d14","title":"连线题"},{"parent":"b47252dabf9f","children":[{"parent":"518c938def47","children":[],"id":"4af60fe62497","title":"填空题都是要绝对准确答案的，要不然机考也不知道怎么评卷。一般是填一个数字或ABCD，跟单选题没有本质区别。遇到2道"}],"id":"518c938def47","title":"填空题"},{"parent":"b47252dabf9f","children":[{"parent":"ac2b7e67b467","children":[],"id":"c8cdfd315eba","title":"从图表中点击符合题目的区域，这些区域都是有明确位置和数量的，本质上也是单选。关键在于要读懂图表。考试中有一道题，给了一个Kanban图，让我点击造成当前项目瓶颈的一个任务。但我之前都没看过Kanban，只能凭感觉选了。"}],"id":"ac2b7e67b467","title":"热点题"},{"parent":"b47252dabf9f","children":[{"parent":"e6b7b1361346","children":[],"id":"4934e4a47cae","title":"本次考试中我只遇到一道计算题，很简单的一道挣值管理题，心算就能得出结果。当然机考是有内置一个计算器app的。"}],"id":"e6b7b1361346","title":"计算题"},{"parent":"b47252dabf9f","children":[{"parent":"1b4b435f3c10","children":[],"id":"a8569eecb64d","title":"180题 / 60%-108题通过"},{"parent":"1b4b435f3c10","children":[],"id":"4ef7e556257d","title":"230分钟"},{"parent":"1b4b435f3c10","children":[{"parent":"4cf350d3eefd","children":[{"parent":"a5ba9d5d0b14","children":[],"id":"88ee60cc9fc3","title":"中国大陆地区笔试，主要以涂卡和机读卡记录成绩"}],"style":{"background-color":"rgb(80, 194, 139)","border-radius":"5px","color":"rgb(255, 255, 255)","border-color":"rgb(255, 255, 255)","border-width":"0px","border-style":"none"},"id":"a5ba9d5d0b14","title":"中国大陆是线下的笔试"},{"parent":"4cf350d3eefd","children":[{"parent":"e3df7fda66a2","children":[],"id":"05a1418bbf81","title":"PearsonVUE软件"},{"parent":"e3df7fda66a2","children":[],"id":"75328e557b5f","title":"每考60题提交一次，提交后不能更改。<br>然后你可以选择休息10分钟或者继续答题，休息时间不计入考试230分钟内。<br>"}],"id":"e3df7fda66a2","title":"远程机考"}],"id":"4cf350d3eefd","title":"方式"}],"id":"1b4b435f3c10","title":"概览"}],"collapsed":false,"id":"b47252dabf9f","title":"考试题型"},{"parent":"2fde316dfeec","children":[{"parent":"0c01531b4ae6","children":[],"id":"ec6671796239","title":"https://www.pmi.org/certifications/project-management-pmp<br>https://www.pmi.org/-/media/pmi/documents/public/pdf/certifications/pmp-examination-content-outline.pdf?v=23267ea5-a9e7-4eb4-b2df-4fbf3f15c61b&amp;sc_lang_temp=zh-CN<br>"}],"id":"0c01531b4ae6","title":"考试范围"}],"pos":{"x":7482.499885559082,"y":11029.000015258789},"id":"2fde316dfeec","title":"PMP备考","free":true},{"parent":"root","lineStyle":{"randomLineColor":"#80BA4C"},"children":[{"parent":"537e2b9cdf43","children":[],"id":"91e254f825eb","title":"有效期3年、1年缓冲期"},{"parent":"537e2b9cdf43","children":[],"id":"f2ba0b3e55a8","title":"续证要求"}],"pos":{"x":7545.999870300293,"y":12171.999969482422},"id":"537e2b9cdf43","title":"PMP证书","free":true},{"parent":"root","lineStyle":{"randomLineColor":"#BE49C4"},"children":[{"parent":"b97a3036c461","children":[{"parent":"eaedd0118821","children":[],"id":"d4ff23953745","title":"Iaas：基础设施即服务"},{"parent":"eaedd0118821","children":[],"id":"0a72b47c28d7","title":"Paas：平台即服务"},{"parent":"eaedd0118821","children":[],"id":"0fea97f6d6ee","title":"Saas：软件即服务"}],"id":"eaedd0118821","title":"云计算商业模式"},{"parent":"b97a3036c461","children":[{"parent":"7139082bf9d0","children":[],"id":"d6f738cc0994","title":"公有云"},{"parent":"7139082bf9d0","children":[],"id":"10dbfbfc0638","title":"私有云"},{"parent":"7139082bf9d0","children":[],"id":"de7b20c3f1b8","title":"混合云"}],"id":"7139082bf9d0","title":"云计算部署模式"},{"parent":"b97a3036c461","children":[{"parent":"65f4112a4a1f","children":[],"id":"9f6d98dedc12","title":"云迁移"},{"parent":"65f4112a4a1f","children":[],"id":"38f985bb2e3a","title":"云就绪"},{"parent":"65f4112a4a1f","children":[],"id":"a69ad0ee3795","title":"云原生"}],"id":"65f4112a4a1f","title":"上云三阶段"},{"parent":"b97a3036c461","children":[{"parent":"9e1db32137cd","children":[{"parent":"937e318549b1","children":[],"id":"07509d029994","title":"最佳路径/最佳实践"},{"parent":"937e318549b1","children":[],"id":"a1e55c80d009","title":"让用户能够以可扩展，可复制方式<b>最大化的使用云的能力</b>"}],"id":"937e318549b1","title":"定义"},{"parent":"9e1db32137cd","children":[{"parent":"bc00e505e3f9","children":[],"id":"a23afe7a9f84","title":"生在云上，长在云上"},{"parent":"bc00e505e3f9","children":[],"id":"0600d08433df","title":"全新的软件开发，测试，发布和运维模式"}],"id":"bc00e505e3f9","title":"愿景"},{"parent":"9e1db32137cd","children":[{"parent":"1fdfadd572c6","children":[],"id":"0964dbb37954","title":"不可变基础设施（容器镜像）"},{"parent":"1fdfadd572c6","children":[],"id":"c30be36b4e34","title":"云应用编排理论（容器设计模式）"}],"id":"1fdfadd572c6","title":"基础理论"},{"parent":"9e1db32137cd","children":[{"parent":"6f77a67075a5","children":[],"id":"6757df4294a6","title":"容器化"},{"parent":"6f77a67075a5","children":[],"id":"f785caf68eed","title":"微服务"},{"parent":"6f77a67075a5","children":[{"parent":"75c111c28630","children":[],"id":"83ecf2820e17","title":"开发运维一体化"}],"id":"75c111c28630","title":"DevOps"},{"parent":"6f77a67075a5","children":[],"id":"7859e1b60b1d","title":"CICD(持续集成持续交付)"}],"id":"6f77a67075a5","title":"四要素"}],"id":"9e1db32137cd","title":"云原生概述"},{"parent":"b97a3036c461","children":[{"parent":"006a8a9344ff","children":[{"parent":"8b6a9c5f6593","children":[],"id":"65229be504b7","title":"应用定义和镜像构建"},{"parent":"8b6a9c5f6593","children":[],"id":"05397988fe37","title":"CI/CD"},{"parent":"8b6a9c5f6593","children":[],"id":"aa0631e71210","title":"数据库"},{"parent":"8b6a9c5f6593","children":[],"id":"ae4c28e0c767","title":"消息和流"}],"id":"8b6a9c5f6593","title":"云应用定义与开发流程"},{"parent":"006a8a9344ff","children":[{"parent":"649c3e0a1419","children":[],"id":"8afee7873196","title":"云应用编排与调度"},{"parent":"649c3e0a1419","children":[],"id":"479978246e04","title":"服务发现"},{"parent":"649c3e0a1419","children":[],"id":"45497e652b8f","title":"远程调用"},{"parent":"649c3e0a1419","children":[],"id":"c45129b7794c","title":"服务代理"},{"parent":"649c3e0a1419","children":[],"id":"79ccef0e65cf","title":"API网关"},{"parent":"649c3e0a1419","children":[],"id":"c061bbf50015","title":"服务网格"}],"id":"649c3e0a1419","title":"云应用编排与管理"},{"parent":"006a8a9344ff","children":[{"parent":"b33cb97839c0","children":[],"id":"a74e11b42578","title":"FaaS"},{"parent":"b33cb97839c0","children":[],"id":"5c587438d1e3","title":"BaaS"}],"id":"b33cb97839c0","title":"无服务"},{"parent":"006a8a9344ff","children":[{"parent":"70a188da430f","children":[],"id":"e2a73f584534","title":"容器运行时"},{"parent":"70a188da430f","children":[],"id":"7acd9be7f5d7","title":"云原生存储技术"},{"parent":"70a188da430f","children":[],"id":"ba19cc73f557","title":"云原生网络技术"}],"id":"70a188da430f","title":"云原生技术基座"},{"parent":"006a8a9344ff","children":[{"parent":"07f45f7ec99b","children":[],"id":"a9da73061fd1","title":"日志"},{"parent":"07f45f7ec99b","children":[],"id":"8d751b8aad07","title":"监控"},{"parent":"07f45f7ec99b","children":[],"id":"2a867c2cea59","title":"追踪"},{"parent":"07f45f7ec99b","children":[],"id":"1c810d28e899","title":"混沌工程"}],"id":"07f45f7ec99b","title":"可观测性和分析"},{"parent":"006a8a9344ff","children":[{"parent":"2eb8b904f77e","children":[],"id":"a5322b8aba53","title":"镜像仓库"},{"parent":"2eb8b904f77e","children":[],"id":"ab9838cb72d6","title":"安全合规"},{"parent":"2eb8b904f77e","children":[],"id":"af72a6ac861a","title":"流程自动化和配置管理"},{"parent":"2eb8b904f77e","children":[],"id":"5f01e94fb17d","title":"密码管理"}],"id":"2eb8b904f77e","title":"应用配置"}],"collapsed":false,"id":"006a8a9344ff","title":"云原生技术领域-CNCF全景图"},{"parent":"b97a3036c461","children":[],"id":"1b7e6f1366f6","title":"云原生12要素"}],"pos":{"x":7673.75,"y":6860},"id":"b97a3036c461","title":"云原生与云计算","free":true},{"parent":"root","lineStyle":{"randomLineColor":"#FD5155"},"children":[{"parent":"593048b42faa","children":[{"parent":"cd0cfebaf3f0","children":[{"parent":"6030d80aa317","children":[{"parent":"b158d2d426ce","children":[],"id":"382e611a501a","title":"某些函数需要进行大量的的计算，占用CPU资源较多，会长时间、不间断（CPU分片）的占用资源，使得其他其他线程获取CPU资源较难<br>"}],"id":"b158d2d426ce","title":"CPU资源"},{"parent":"6030d80aa317","children":[{"parent":"c374f5aeadca","children":[],"id":"a5a9946fd1e2","title":"代码中，数据结构的不规范使用等，使得对象无法回收，导致的内存溢出、内存泄露问题<br>"}],"id":"c374f5aeadca","title":"内存"},{"parent":"6030d80aa317","children":[],"id":"69f6fb2c0358","title":"磁盘IO"},{"parent":"6030d80aa317","children":[{"parent":"3d73c59cd54d","children":[],"id":"679c8f2c803e","title":"网络带宽是指在单位时间（一般指的是1秒钟）内能传输的数据量。网络带宽小于真实的传输数据量，就会变慢<br>"}],"id":"3d73c59cd54d","title":"网络带宽"},{"parent":"6030d80aa317","children":[{"parent":"7beffcd0f588","children":[],"id":"a0670ada6bd4","title":"Java中，抛出异常需要构建异常栈，对异常进行捕获和处理，这个也十分耗时"}],"id":"7beffcd0f588","title":"异常"},{"parent":"6030d80aa317","children":[],"id":"2d392e2bf466","title":"数据库"},{"parent":"6030d80aa317","children":[{"parent":"859d0f76868a","children":[],"id":"7a211ea9c751","title":"Java同步锁的优化"}],"id":"859d0f76868a","title":"锁竞争"}],"id":"6030d80aa317","title":"因素"},{"parent":"cd0cfebaf3f0","children":[{"parent":"ab1d3d72f60f","children":[],"id":"716653043b81","title":"响应时间"},{"parent":"ab1d3d72f60f","children":[{"parent":"bea73c5d7d92","children":[{"parent":"3ab92173cd04","children":[{"parent":"344c1abbe68b","children":[],"id":"d20ee2271b75","title":"IOPS（每秒输入输出量）"},{"parent":"344c1abbe68b","children":[],"id":"18d8c4b0dc7c","title":"数据吞吐量（每秒可以传输的数据量）"}],"id":"344c1abbe68b","title":"磁盘吞吐量"},{"parent":"3ab92173cd04","children":[],"id":"f6a1063ec51b","title":"网络吞吐量"}],"id":"3ab92173cd04","title":"TPS（每秒事务处理量）"}],"id":"bea73c5d7d92","title":"吞吐量"},{"parent":"ab1d3d72f60f","children":[{"parent":"0da93325410d","children":[],"id":"90dace5c97d2","title":"CPU使用率"},{"parent":"0da93325410d","children":[],"id":"9352067466f3","title":"内存使用率"},{"parent":"0da93325410d","children":[],"id":"3374960b30c6","title":"磁盘IO"},{"parent":"0da93325410d","children":[],"id":"dae135be78ea","title":"网络IO"}],"id":"0da93325410d","title":"计算机资源分配使用率"},{"parent":"ab1d3d72f60f","children":[],"id":"0d72a1814522","title":"负载承受能力"}],"id":"ab1d3d72f60f","title":"指标"},{"parent":"cd0cfebaf3f0","children":[{"parent":"b3b3fc421465","children":[{"parent":"16a99fd9c487","children":[],"id":"bb427624610b","title":"微基准性能测试"},{"parent":"16a99fd9c487","children":[],"id":"42c1fb034be3","title":"宏基准性能测试"}],"id":"16a99fd9c487","title":"类型"},{"parent":"b3b3fc421465","children":[{"parent":"bb947c8fc066","children":[{"parent":"48b79fb3a462","children":[],"id":"c3a232a747a8","title":"在&nbsp;Java&nbsp;编程语言和环境中，.java&nbsp;文件编译成为&nbsp;.class&nbsp;文件后，机器还是无法直接运行&nbsp;.class&nbsp;文件中的字节码，需要通过解释器将字节码转换成本地机器码才能运行。"},{"parent":"48b79fb3a462","children":[],"id":"3d6d1c5323df","title":"JVM因为JIT的原因，会把一些热点代码编译成机器码存在内存中，以此来提升速度"}],"id":"48b79fb3a462","title":"热身问题"},{"parent":"bb947c8fc066","children":[{"parent":"962d3fbca314","children":[],"id":"3ee82feef8f4","title":"如机器其他进程的影响、网络波动以及每个阶段&nbsp;JVM&nbsp;垃圾回收的不同等等会影响结果"},{"parent":"962d3fbca314","children":[],"id":"738b8d0e8e0b","title":"多次测试，取平均值"}],"id":"962d3fbca314","title":"结果不稳定"},{"parent":"bb947c8fc066","children":[],"id":"51c5de74304b","title":"多JVM的影响"}],"boundaries":[{"boundary":true,"parent":"bb947c8fc066","boundRank":1,"children":[],"range":"0,2","style":{"lineType":"1","dasharray":"6,3","opacity":"0.1","lineWidth":"2"},"id":"5b8d69874c4e","title":"外框"}],"id":"bb947c8fc066","title":"注意点"},{"parent":"b3b3fc421465","children":[{"parent":"be67d193322e","children":[],"id":"a9f40f6edcad","title":"通过上面的测试结果，对比指标标准，定位瓶颈位置（网络？磁盘IO？数据库？等），分析导致瓶颈的原因"},{"parent":"be67d193322e","children":[{"parent":"d9c67ac22703","children":[{"parent":"c13c21312899","children":[{"parent":"3b5397bcb943","children":[],"id":"072f9ebb243e","title":"数据结构是否合理使用，<br>是否存在内存泄露（Map里面对象的变化），<br>是否存在效率低下的操作（例如LinkedList使用for循环遍历）<br>"}],"id":"3b5397bcb943","title":"代码优化"},{"parent":"c13c21312899","children":[{"parent":"b93d19b1c1c5","children":[],"id":"b2e19772feef","title":"设计模式的合理使用，可以一定程度减少性能消耗。<br>例如单例模式、原型模式、享元模式可以在一定程度上，减少创建销毁对象的时间<br>"}],"id":"b93d19b1c1c5","title":"优化设计"},{"parent":"c13c21312899","children":[{"parent":"198758dccf24","children":[],"id":"b46c310ae059","title":"减少时间复杂度"}],"id":"198758dccf24","title":"优化算法"}],"id":"c13c21312899","title":"应用调优（通常是资源不足导致异常或性能瓶颈）"},{"parent":"d9c67ac22703","children":[{"parent":"acb3baf52d76","children":[],"id":"4c380e4880b2","title":"操作系统调优"},{"parent":"acb3baf52d76","children":[],"id":"8c722030079c","title":"JVM调优"},{"parent":"acb3baf52d76","children":[],"id":"b30753c95bd1","title":"组件调优"}],"id":"acb3baf52d76","title":"系统调优"},{"parent":"d9c67ac22703","children":[{"parent":"ab2d39d993c1","children":[],"id":"ac0cbabb5cfe","title":"时间换空间"},{"parent":"ab2d39d993c1","children":[],"id":"08e08e530379","title":"空间换时间"}],"id":"ab2d39d993c1","title":"调优策略"}],"collapsed":true,"boundaries":[{"boundary":true,"parent":"d9c67ac22703","children":[],"range":"0,2","style":{"lineType":"1","dasharray":"6,3","opacity":"0.1","lineWidth":"2"},"id":"37dab7663e77","title":"外框"}],"id":"d9c67ac22703","title":"常见调优策略"}],"id":"be67d193322e","title":"分析"}],"id":"b3b3fc421465","title":"性能测试攻略"}],"id":"cd0cfebaf3f0","title":"性能调优标准（因素和指标）"},{"parent":"593048b42faa","children":[{"parent":"97fe03dbbbce","children":[{"parent":"fcece0c3cf1a","children":[],"id":"20fb071c4732","title":"String"},{"parent":"fcece0c3cf1a","children":[],"id":"3336d823e729","title":"慎用正则"},{"parent":"fcece0c3cf1a","children":[],"id":"5253bfa3c2dc","title":"ArrayList和LinkedList的正确使用"},{"parent":"fcece0c3cf1a","children":[],"id":"6d1aa537272e","title":"stream的正确使用"},{"parent":"fcece0c3cf1a","children":[],"id":"6227631cb216","title":"hashMap"},{"parent":"fcece0c3cf1a","children":[{"parent":"7680bfe1f787","children":[{"parent":"aa14f9e87eb8","children":[],"id":"cdaf22cb3956","title":"性能差"},{"parent":"aa14f9e87eb8","children":[],"id":"dd23f1e0c8e4","title":"不安全"},{"parent":"aa14f9e87eb8","children":[],"id":"f8f2ddb6ef2c","title":"无法跨语言"}],"id":"aa14f9e87eb8","title":"缺陷"}],"id":"7680bfe1f787","title":"避免使用Java序列化"},{"parent":"fcece0c3cf1a","children":[{"parent":"2be1560bd907","children":[{"parent":"501e885e7ef8","children":[],"id":"c392229ff1a5","title":"SpringCloud是基于Feign组件实现的RPC通信（基于Http+Json序列化实现）"},{"parent":"501e885e7ef8","children":[],"id":"51778f9ab662","title":"Dubbo是基于SPI扩展了很多RPC通信框架，包括RMI、Dubbo、Hessian等RPC通信框架（默认是Dubbo+Hessian序列化）"}],"id":"501e885e7ef8","title":"选择合适的协议，能大幅度提升性能"}],"id":"2be1560bd907","title":"RPC通信"}],"id":"fcece0c3cf1a","title":"Java编程调优（算法的时间复杂度、空间复杂度；网络通行调优等）"},{"parent":"97fe03dbbbce","children":[{"parent":"6ae32f8126df","children":[{"parent":"799cb5eee14c","children":[],"id":"401ad0b7f454","title":"Synchronized锁优化（JDK8的优化）"},{"parent":"799cb5eee14c","children":[],"id":"5db423973cea","title":"Lock锁优化"},{"parent":"799cb5eee14c","children":[],"id":"cf25c8d1a504","title":"乐观锁使用（CAS）"}],"id":"799cb5eee14c","title":"锁"},{"parent":"6ae32f8126df","children":[{"parent":"8844f2967b05","children":[],"id":"254cb4fc749b","title":"哪些操作导致了上下文切换"},{"parent":"8844f2967b05","children":[],"id":"d5f78efe1540","title":"如何优化上下文切换"}],"id":"8844f2967b05","title":"上下文切换"},{"parent":"6ae32f8126df","children":[{"parent":"9914f4faba79","children":[],"id":"4bb575d19f0f","title":"https://img-blog.csdnimg.cn/6322a95d92cc4eb2b8eeae00fb0c2702.png"}],"id":"9914f4faba79","title":"并发容器的合理选择"},{"parent":"6ae32f8126df","children":[{"parent":"dc9fc06f8ebf","children":[],"id":"eab46344bbc8","title":"线程数=N（CPU核数）*（1+WT（线程等待时间）/ST（线程时间运行时间））"}],"id":"dc9fc06f8ebf","title":"如何设计线程池大小"},{"parent":"6ae32f8126df","children":[],"id":"dc61fad50c8e","title":"如何利用协程优化多线程业务"}],"id":"6ae32f8126df","title":"多线程性能调优（锁竞争）"},{"parent":"97fe03dbbbce","children":[],"id":"19462a535ae9","title":"JVM性能检测及调优（对象的创建、回收和内存分配）"},{"parent":"97fe03dbbbce","children":[],"id":"f11a4025e97b","title":"设计模式调优"},{"parent":"97fe03dbbbce","children":[],"id":"e56ddf3ae660","title":"数据库性能调优（表设计、索引）"}],"boundaries":[{"boundary":true,"parent":"97fe03dbbbce","boundRank":1,"children":[],"range":"0,4","style":{"lineType":"1","dasharray":"6,3","opacity":"0.1","fill":"#bf1e1b","lineWidth":"2"},"id":"36ba19a6c20a","title":"外框"}],"id":"97fe03dbbbce","title":"调优过程标准"}],"pos":{"x":5366.000118255615,"y":9256.999998092651},"id":"593048b42faa","title":"Java性能调优","free":true},{"parent":"root","lineStyle":{"randomLineColor":"#FD5155"},"children":[{"parent":"f18eb684a1f1","children":[{"parent":"c5a8be140847","children":[],"id":"204b7dcdc2d1","title":"（一种远程过程调用模式，是一种标准，不是一种协议；RPC是一个完整的远程调用方案，它包括了：接口规范+序列化反序列化规范+通信协议等）"}],"id":"c5a8be140847","title":"定义"},{"parent":"f18eb684a1f1","children":[],"id":"e9cecf11f5f8","title":"接口规范"},{"parent":"f18eb684a1f1","children":[],"id":"edcb69edfb03","title":"序列化规范"},{"parent":"f18eb684a1f1","children":[{"parent":"76fd9d687736","children":[],"id":"61d882e8791e","title":"自定义协议（HTTP协议太多冗余字段，所以有很多是自定义协议）"},{"parent":"76fd9d687736","children":[],"id":"95ee2ab0d655","title":"HTTP协议"},{"parent":"76fd9d687736","children":[],"id":"19d1c1dc11e1","title":"HTTP2协议"},{"parent":"76fd9d687736","children":[],"id":"1d04527a4b5d","title":"Hessian"},{"parent":"76fd9d687736","children":[],"id":"f35dba9132ef","title":"RMI"},{"parent":"76fd9d687736","children":[],"id":"915195f34eb7","title":"webservice"},{"parent":"76fd9d687736","children":[],"id":"4d4b92273cf5","title":"thrift"}],"id":"76fd9d687736","title":"通信协议"}],"pos":{"x":3877,"y":10365},"id":"f18eb684a1f1","title":"RPC","free":true}],"background":"#F7F7F7","root":true,"theme":"delicate_caihong","id":"root","title":"分布式<br>参考：https://juejin.cn/post/6844903967701336078#heading-26","lines":{"56a3afff5105":{"realEnd":{"x":11899.609436035156,"y":7975.3125},"start":{"x":"0.5","y":"1.0","index":4},"angle":229.88997545497648,"styles":{"color":"#ffffff","lineColor":"rgb(113, 203, 45)","lineWidth":3},"from":"c493ceb3a406","end":{"x":"0.5","y":"0.0","index":2},"id":"56a3afff5105","realStart":{"x":11818.109436035156,"y":7878.5625},"to":"b3c63fd4f25b","points":[]},"22c08e7e5e42":{"realEnd":{"x":11197.749526977539,"y":8881.806509399414},"start":{"x":"0.5","y":"1.0","index":3},"angle":6.5941072345712834,"styles":{"color":"#ffffff","lineColor":"rgb(113, 203, 45)","lineWidth":3},"from":"cbd592c10e24","end":{"x":"1.0","y":"0.7","index":3},"id":"22c08e7e5e42","realStart":{"x":11552.374542236328,"y":7718.0002365112305},"to":"60d7d9fbaf6e","pts":[{"x":1013.0626356336816,"y":1083.0155843098955},{"x":1897.3055555555566,"y":220.93060980902737}],"points":[{"x":12565.43717787001,"y":8785.515820821125},{"x":13053.555082533096,"y":9096.337119208441}]},"9c147bf31e2c":{"realEnd":{"x":11037.914245605469,"y":6103.312561035156},"start":{"x":"0.5","y":"0.0","index":1},"angle":283.3110747953516,"styles":{"color":"#ffffff","lineColor":"rgb(113, 203, 45)","lineWidth":3},"from":"b3482079c48f","end":{"x":"0.5","y":"1.0","index":3},"id":"9c147bf31e2c","realStart":{"x":11083.414245605469,"y":5911.000061035156},"to":"7ea19c06b196","label":"对立","points":[]},"1b85672a28cc":{"realEnd":{"x":11197.749526977539,"y":8865.806509399414},"start":{"x":"0.8","y":"1.0","index":3},"angle":352.949597997444,"styles":{"color":"#ffffff","lineColor":"rgb(113, 203, 45)","lineWidth":3},"from":"ad1d8f3523d1","end":{"x":"1.0","y":"0.2","index":2},"id":"1b85672a28cc","realStart":{"x":11857.174526977538,"y":8798.265869140625},"to":"60d7d9fbaf6e","pts":[{"x":924.2916666666679,"y":151.16145833333212},{"x":100.95309787326369,"y":-16.953016493054747}],"points":[{"x":12557.666193644207,"y":8915.927327473957},{"x":11257.202624850803,"y":8858.45349290636}]},"c6c55650744c":{"realEnd":{"x":11839.109436035156,"y":8268.765640258789},"start":{"x":"0.4","y":"1.0","index":4},"angle":297.2943378228645,"styles":{"color":"#ffffff","lineColor":"rgb(113, 203, 45)","lineWidth":3},"from":"88f90ba31bc3","end":{"x":"0.8","y":"0.0","index":2},"id":"c6c55650744c","realStart":{"x":11882.309436035157,"y":8185.046875},"to":"270f4a13480f","points":[]},"c6698a9b323a":{"realEnd":{"x":11904.609436035156,"y":8153.046875},"start":{"x":"0.5","y":"1.0","index":3},"angle":268.03501012419065,"styles":{"color":"#ffffff","lineColor":"rgb(113, 203, 45)","lineWidth":3},"from":"b3c63fd4f25b","end":{"x":"0.5","y":"0.0","index":1},"id":"c6698a9b323a","realStart":{"x":11899.609436035156,"y":8007.3125},"to":"88f90ba31bc3","points":[]}},"structure":"mind_free"}},"meta":{"exportTime":"2022-07-29 07:33:46","member":"60740a737d9c081712e3e2bf","diagramInfo":{"creator":"60740a737d9c081712e3e2bf","created":"2022-03-11 15:13:01","modified":"2022-07-29 07:33:30","title":"杂项","category":"mind_free"},"id":"622af67d7d9c08076dfeac4c","type":"ProcessOn Schema File","version":"1.0"}}